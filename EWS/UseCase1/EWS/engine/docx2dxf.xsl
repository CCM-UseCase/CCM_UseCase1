<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
		xmlns:dlg="http://www.hpexstream.com/2009/XSL/HPExstream" 
		xmlns:pkg="http://schemas.microsoft.com/office/2006/xmlPackage" 
		xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"
		xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" 
		xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing"
		xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture"
		xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"		
		xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"
		xmlns:v="urn:schemas-microsoft-com:vml"		
		xmlns:o="urn:schemas-microsoft-com:office:office"		
		xmlns:xs="http://www.w3.org/2001/XMLSchema" 
		xmlns:dxf="http://www.hpexstream.com/2009/XSL/DXF" 
		xmlns:fo="http://www.w3.org/1999/XSL/Format" 
		xmlns:rels="http://schemas.openxmlformats.org/package/2006/relationships"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing"
		exclude-result-prefixes="pkg w wp a pic r m v o rels xs">
		
	<xsl:output method="xml" encoding="UTF-8" indent="yes" doctype-system="ExstreamObjectAndContent.dtd"/>
	
	<!-- parameters passed to the transform -->
	<xsl:param name="mustFlow"/>
  <xsl:param name="startingFlowId"/>
  <xsl:param name="revertTabbingCR63521"/>

  <!-- define doc-level vars for simplicity -->
	<xsl:variable name="xmlData" select="pkg:package/pkg:part/pkg:xmlData"/>
	<xsl:variable name="numbering" select="$xmlData/w:numbering"/>
	<xsl:variable name="theme" select="$xmlData/a:theme"/>
	<xsl:variable name="styles" select="pkg:package/pkg:part[@pkg:name='/word/styles.xml']/pkg:xmlData/w:styles"/>
	<xsl:variable name="settings" select="$xmlData/w:settings"/>
  <xsl:variable name="footnotes" select="$xmlData/w:footnotes"/>
  <xsl:variable name="endnotes" select="$xmlData/w:endnotes"/>

  <!-- key maps to various parts of the doc -->
	<xsl:key name="key.doc.rels" use="@Id" match="pkg:package/pkg:part[@pkg:name='/word/_rels/document.xml.rels']/pkg:xmlData/rels:Relationships/rels:Relationship"/>
	<xsl:key name="key.styles" use="@w:styleId" match="pkg:package/pkg:part[@pkg:name='/word/styles.xml']/pkg:xmlData/w:styles/w:style"/>
	<xsl:key name="key.theme.colors" use="local-name()" match="pkg:package/pkg:part/pkg:xmlData/a:theme/a:themeElements/a:clrScheme/*"/>
  <xsl:key name="key.footnote" use="@w:id" match="pkg:package/pkg:part[@pkg:name='/word/footnotes.xml']/pkg:xmlData/w:footnotes/w:footnote"/>
  <xsl:key name="key.endnote" use="@w:id" match="pkg:package/pkg:part[@pkg:name='/word/endnotes.xml']/pkg:xmlData/w:endnotes/w:endnote"/>

  <!-- define doc-level default properties -->
	<xsl:variable name="minorFont" select="$theme/a:themeElements/a:fontScheme/a:minorFont/a:latin/@typeface"/>
	<xsl:variable name="majorFont" select="$theme/a:themeElements/a:fontScheme/a:majorFont/a:latin/@typeface"/>
	<xsl:variable name="defaults.style.doc.rPr" select="$styles/w:docDefaults/w:rPrDefault/w:rPr"/>
	<xsl:variable name="defaults.style.doc.pPr" select="$styles/w:docDefaults/w:pPrDefault/w:pPr"/>
	<xsl:variable name="defaults.style.paragraph" select="$styles/w:style[@w:default='1' and @w:type='paragraph']"/>  
	<xsl:variable name="defaults.style.character" select="$styles/w:style[@w:default='1' and @w:type='character']"/>  
	<xsl:variable name="defaults.style.table" select="$styles/w:style[@w:default='1' and @w:type='table']"/>	
	<xsl:variable name="defaults.style.numbering" select="$styles/w:style[@w:default='1' and @w:type='numbering']"/>	
	
	<xsl:variable name="default.tab.stop">
		<xsl:call-template name="convert.resolution">
			<xsl:with-param name="res.from" select="$settings/w:defaultTabStop/@w:val"/>
		</xsl:call-template>
	</xsl:variable>

  <xsl:variable name="generateTOC">
    <xsl:choose>
      <xsl:when test="$mustFlow = 'true' and contains(//w:instrText, 'TOC ')">
        <xsl:apply-templates mode="editTOC" select="//w:instrText[contains(., 'TOC ')]"/>
      </xsl:when>
      <xsl:otherwise>false</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="TOCLevel1">
    <xsl:choose>
      <xsl:when test="$generateTOC = 'true'">
        <xsl:apply-templates mode="TOCLevel1" select="//w:instrText[contains(., 'TOC ')]"/>
      </xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="TOCLevel2">
    <xsl:choose>
      <xsl:when test="$generateTOC = 'true'">
        <xsl:apply-templates mode="TOCLevel2" select="//w:instrText[contains(., 'TOC ')]"/>
      </xsl:when>
      <xsl:otherwise>3</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:variable name="endOfTOC">
    <!-- need to skip the sample TOC generated by Word-->
    <xsl:choose>
      <xsl:when test="$generateTOC = 'true'">
        <xsl:apply-templates mode="findTOCEnd" select="//w:body/descendant::w:fldChar[1]">
          <xsl:with-param name="TOCLevel" select="0"/>
          <xsl:with-param name="fldCharCount" select="0"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>0</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <xsl:template match="/">
    <xsl:if test="$mustFlow != 'true'">
      <xsl:apply-templates select="$xmlData/w:document">
        <xsl:with-param name="doc.part.rels" select="''"/>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:if test="$mustFlow = 'true'">
      <xsl:apply-templates mode="flow" select="$xmlData/w:document"/>
    </xsl:if>
  </xsl:template>

  <xsl:variable name="hasFootnotes">
    <xsl:choose>
      <xsl:when test="$mustFlow = 'true' and (//w:footnoteReference or //w:endnoteReference)">true</xsl:when>
      <xsl:otherwise>false</xsl:otherwise>
    </xsl:choose>
  </xsl:variable>

  <!-- ========= Beginning of flowing DOCX placeholder templates ========= -->

  <xsl:template mode="findTOCEnd" match="w:fldChar">
    <xsl:param name="TOCLevel"/>
    <xsl:param name="fldCharCount"/>
    <xsl:variable name="newLevel">
      <xsl:choose>
        <xsl:when test="./@w:fldCharType='begin'">
          <xsl:value-of select="$TOCLevel + 1"/>
        </xsl:when>
        <xsl:when test="./@w:fldCharType='end'">
          <xsl:value-of select="$TOCLevel - 1"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="$TOCLevel"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="newFldCharCount" select="$fldCharCount + 1"/>
    <xsl:choose>
      <xsl:when test="$newLevel > '0'">
        <xsl:apply-templates mode="findTOCEnd" select="following::w:fldChar[1]">
          <xsl:with-param name="TOCLevel" select="$newLevel"/>
          <xsl:with-param name="fldCharCount" select="$newFldCharCount"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$newFldCharCount"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="editTOC" match="w:instrText">
    <xsl:if test="contains(., '\a')">
      <xsl:message terminate="no">
        <xsl:text>The table of contents contains captioned items. OpenText Exstream does not support captioned items in a table of contents. These entries will be ignored.</xsl:text>
      </xsl:message>
   </xsl:if>
    <xsl:if test="contains(., '\c')">
      <xsl:message terminate="no">
        <xsl:text>The table of contents contains items marked by an SEQ field. OpenText Exstream does not support SEQ fields in a table of contents. These entries will be ignored.</xsl:text>
      </xsl:message>
    </xsl:if>
    <xsl:if test="contains(., '\s')">
      <xsl:message terminate="no">
        <xsl:text>The table of contents contains sequence numbers that precede the table of contents page number. OpenText Exstream does not support sequence numbers in a table of contents. These entries will be ignored.</xsl:text>
      </xsl:message>
    </xsl:if>
    <xsl:if test="contains(., '\n')">
      <xsl:message terminate="no">
        <xsl:text>The table of contents contains hidden entries. OpenText Exstream does not support hidden entries in a table of contents. All hidden entries will be included in the final table of contents.</xsl:text>
      </xsl:message>
    </xsl:if>
    <xsl:if test="contains(., '\t')">
      <xsl:message terminate="no">
        <xsl:text>The table of contents contains custom formatting. OpenText Exstream does not support custom formatting in a table of contents. These entries will be ignored.</xsl:text>
      </xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="contains(., '\b')">
        <xsl:message terminate="no">
          <xsl:text>The table of contents contains only bookmarked text. Bookmarked entries in a table of contents are not supported by OpenText Exstream and the table of contents will not be generated.</xsl:text>
        </xsl:message>
        <xsl:text>false</xsl:text>
      </xsl:when>
      <xsl:when test="contains(., '\f')">
        <xsl:message terminate="no">
          <xsl:text>The table of contents contains table of contents entry fields. OpenText Exstream does not support table of contents entry fields. The table of contents will not be generated.</xsl:text>
        </xsl:message>
        <xsl:text>false</xsl:text>
      </xsl:when>
      <xsl:when test="not(contains(., '\u'))">
        <xsl:message terminate="no">
          <xsl:text>The table of contents does not include a specific paragraph outline. OpenText Exstream supports only applied paragraph outlining. The table of contents will not be generated.</xsl:text>
        </xsl:message>
        <xsl:text>false</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>true</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="TOCLevel1" match="w:instrText">
    <xsl:choose>
      <xsl:when test="contains(., '\o')">
        <xsl:value-of select="substring-before(substring-after(substring-after(string(.),'\o'), '&quot;'), '-') - 1"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>0</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="TOCLevel2" match="w:instrText">
    <xsl:choose>
      <xsl:when test="contains(., '\o')">
        <xsl:value-of select="substring-before(substring-after(substring-after(string(.),'\o'), '-'), '&quot;') - 1"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>0</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="generateTOC" match="w:instrText">
    <dlg:text>
      <xsl:call-template name="apply.default.dlg.object.props"/>
      <xsl:attribute name="can-split">true</xsl:attribute>
      <xsl:attribute name="flow-target-type">any</xsl:attribute>
      <xsl:attribute name="ignore-relative">no</xsl:attribute>
      <xsl:attribute name="min-height">0</xsl:attribute>
      <xsl:attribute name="pos-rel-to-above">1</xsl:attribute>
      <xsl:attribute name="v-auto-size">true</xsl:attribute>
      <xsl:apply-templates mode="apply.TOC.properties" select="following::w:sectPr[1]">
        <xsl:with-param name="firstOnPage" select="'true'"/>
      </xsl:apply-templates>
      <fo:flow>
        <xsl:call-template name="create.one.section">
          <xsl:with-param name="placeAfterTOC" select="'false'"/>
        </xsl:call-template>
      </fo:flow>
    </dlg:text>
    <dlg:table-of-contents>
      <xsl:call-template name="apply.default.dlg.object.props"/>
      <xsl:attribute name="can-split">true</xsl:attribute>
      <xsl:attribute name="flow-target-type">any</xsl:attribute>
      <xsl:attribute name="ignore-relative">no</xsl:attribute>
      <xsl:attribute name="min-height">0</xsl:attribute>
      <xsl:attribute name="pos-rel-to-above">1</xsl:attribute>
      <xsl:attribute name="leader">.</xsl:attribute>
      <xsl:attribute name="level-indent">
        <xsl:choose>
          <xsl:when test="key('key.styles', 'TOC2')">
            <xsl:variable name="toc.style" select="key('key.styles', 'TOC2')"/>
            <xsl:choose>
              <xsl:when test="$toc.style/w:pPr/w:ind/@w:left">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$toc.style/w:pPr/w:ind/@w:left"/>
                </xsl:call-template>
              </xsl:when>
              <xsl:otherwise> 250 </xsl:otherwise>
            </xsl:choose>
          </xsl:when>
          <xsl:otherwise> 250 </xsl:otherwise>
        </xsl:choose>
      </xsl:attribute>
      <xsl:attribute name="num-levels">
        <xsl:value-of select="$TOCLevel2 - $TOCLevel1 + 1"/>
      </xsl:attribute>
      <!-- TODO need to get this from page size -->
      <xsl:attribute name="page-number-position">right-column</xsl:attribute>
      <xsl:attribute name="toc-type">sub-document</xsl:attribute>
      <xsl:attribute name="v-auto-size">true</xsl:attribute>
      <xsl:attribute name="column-width">500</xsl:attribute>
      <xsl:attribute name="design-var-ndx">0</xsl:attribute>
      <xsl:attribute name="entry-wrap">true</xsl:attribute>
      <xsl:attribute name="justification">right</xsl:attribute>
      <xsl:choose>
        <xsl:when test="contains(., '\h')">
          <xsl:attribute name="toc-hyperlink">true</xsl:attribute>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="toc-hyperlink">false</xsl:attribute>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:apply-templates mode="apply.TOC.properties" select="following::w:sectPr[1]">
        <xsl:with-param name="firstOnPage" select="'false'"/>
      </xsl:apply-templates>
      <xsl:call-template name="make.TOC.level">
        <xsl:with-param name="TOCLevel" select="$TOCLevel1"/>
      </xsl:call-template>
    </dlg:table-of-contents>
  </xsl:template>

  <xsl:template name="make.TOC.level">
    <xsl:param name="TOCLevel"/>
    <dlg:table-of-contents-level>
      <xsl:attribute name="include-leaders">true</xsl:attribute>
      <xsl:attribute name="level-indent">
        <xsl:value-of select="$TOCLevel - $TOCLevel1"/>
      </xsl:attribute>
      <xsl:attribute name="font-style">normal</xsl:attribute>
      <!-- apply doc default run styles -->
      <xsl:apply-templates select="$defaults.style.doc.rPr">
        <xsl:with-param name="doc.defaults" select="'true'"/>
      </xsl:apply-templates>
      <xsl:call-template name="resolve.TOC.style">
        <xsl:with-param name="TOCLevel" select="$TOCLevel"/>
      </xsl:call-template>
    </dlg:table-of-contents-level>
    <xsl:variable name="newLevel" select="$TOCLevel+1"/>
    <xsl:if test="not($newLevel&gt;$TOCLevel2)">
      <xsl:call-template name="make.TOC.level">
        <xsl:with-param name="TOCLevel" select="$newLevel"/>
      </xsl:call-template>
    </xsl:if>
  </xsl:template>

  <xsl:template name="resolve.TOC.style">
    <xsl:param name="TOCLevel"/>
    <xsl:variable name="strLevel" select="concat('TOC', $TOCLevel - $TOCLevel1 + 1)"/>
    <xsl:choose>
      <xsl:when test="key('key.styles', $strLevel)">
        <xsl:apply-templates mode="apply.TOC.level.props" select="key('key.styles', $strLevel)"/>
      </xsl:when>
      <xsl:when test="$TOCLevel &lt;= $TOCLevel1">
        <xsl:apply-templates mode="apply.TOC.level.props" select="key('key.styles', 'Normal')"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="resolve.TOC.style">
          <xsl:with-param name="TOCLevel" select="$TOCLevel - 1"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="apply.TOC.level.props" match="w:style">
    <xsl:if test="w:basedOn">
      <xsl:apply-templates mode="apply.TOC.level.props" select="key('key.styles', w:basedOn/@w:val)"/>
    </xsl:if>
    <xsl:if test="w:pPr/w:spacing/@w:before">
      <xsl:attribute name="space-above">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="w:pPr/w:spacing/@w:before"/>
        </xsl:call-template>
      </xsl:attribute>
    </xsl:if>
    <xsl:apply-templates select="w:rPr/*"/>
  </xsl:template>

  <xsl:template mode="outlineLevel" match="w:style">
    <xsl:choose>
      <xsl:when test="w:pPr/w:outlineLvl">
        <xsl:value-of select="w:pPr/w:outlineLvl/@w:val"/>
      </xsl:when>
      <xsl:when test="w:link">
        <xsl:apply-templates mode="linkOutlineLevel" select="key('key.styles', w:link/@w:val)"/>
      </xsl:when>
      <xsl:otherwise>
        999
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="linkOutlineLevel" match="w:style">
    <xsl:choose>
      <xsl:when test="w:pPr/w:outlineLvl">
        <xsl:value-of select="w:pPr/w:outlineLvl/@w:val"/>
      </xsl:when>
      <xsl:otherwise>
        999
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="flow" match="w:document">
    <dlg:document>
      <xsl:apply-templates mode="document" select="w:body/descendant::w:sectPr[1]">
        <xsl:with-param name="section.number" select="$startingFlowId"/>
      </xsl:apply-templates>
    </dlg:document>
  </xsl:template>

  <xsl:template mode="document" match="w:sectPr">
    <xsl:param name="section.number"/>
    <xsl:variable name="use">
      <xsl:choose>
        <xsl:when test="w:type/@w:val='continuous' and not(ancestor::w:p) and preceding::w:sectPr">false</xsl:when>
        <xsl:otherwise>true</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$use = 'true'">
      <xsl:call-template name="do.section">
        <xsl:with-param name="section.number" select="$section.number"/>
      </xsl:call-template>
      <xsl:apply-templates mode="document" select="following::w:sectPr[1]">
        <xsl:with-param name="section.number" select="$section.number + 1"/>
      </xsl:apply-templates>
    </xsl:if>
  </xsl:template>

  <xsl:template name="do.section">
    <xsl:param name="section.number"/>
    <xsl:if test="w:cols and w:cols/@w:num and w:cols/@w:num &gt; 1">
      <xsl:message terminate="no">
        <xsl:text>Page columns are not supported by DXF.  Page content will appear in a single column</xsl:text>
      </xsl:message>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="parent::w:body or not(./w:type) or ./w:type/@w:val='nextPage'">
        <xsl:call-template name="apply.document.props"/>
        <xsl:call-template name="make.page">
          <xsl:with-param name="topMargin" select="./w:pgMar/@w:top"/>
          <xsl:with-param name="leftMargin" select="./w:pgMar/@w:left"/>
          <xsl:with-param name="rightMargin" select="./w:pgMar/@w:right"/>
          <xsl:with-param name="bottomMargin" select="./w:pgMar/@w:bottom"/>
          <xsl:with-param name="pageHeight" select="./w:pgSz/@w:h"/>
          <xsl:with-param name="pageWidth" select="./w:pgSz/@w:w"/>
          <xsl:with-param name="section.number" select="$section.number"/>
        </xsl:call-template>
        <xsl:call-template name="make.section">
          <xsl:with-param name="doc.part.rels" select="''"/>
          <xsl:with-param name="topMargin" select="./w:pgMar/@w:top"/>
          <xsl:with-param name="leftMargin" select="./w:pgMar/@w:left"/>
          <xsl:with-param name="rightMargin" select="./w:pgMar/@w:right"/>
          <xsl:with-param name="bottomMargin" select="w:pgMar/@w:bottom"/>
          <xsl:with-param name="pageHeight" select="./w:pgSz/@w:h"/>
          <xsl:with-param name="pageWidth" select="./w:pgSz/@w:w"/>
          <xsl:with-param name="section.number" select="$section.number"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
          <xsl:message terminate="no">
            <xsl:text>A section was encountered with the following section properties type: '</xsl:text>
            <xsl:value-of select="./w:type/@w:val"/>
            <xsl:text>'. OpenText Exstream does not support this type of section for DOCX import and this section break will be ignored.</xsl:text>
          </xsl:message>
        </xsl:otherwise>
      </xsl:choose>
  </xsl:template>

  <xsl:template name="make.page">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="section.number"/>
    <dlg:doc-message-use>
      <xsl:call-template name="apply.message.use.props">
        <xsl:with-param name="section.number" select="$section.number"/>
      </xsl:call-template>
      <dlg:page>
        <xsl:call-template name="apply.page.props"/>
        <xsl:if test="$generateTOC = 'true'">
          <xsl:attribute name="has-toc">true</xsl:attribute>
        </xsl:if>
        <xsl:if test="$hasFootnotes = 'true'">
          <xsl:attribute name="has-footnote">true</xsl:attribute>
          <dlg:page-frame>
            <xsl:call-template name="apply.footnote.frame.props"/>
          </dlg:page-frame>
        </xsl:if>
        <dlg:page-frame>
          <xsl:call-template name="apply.page.frame.props">
            <xsl:with-param name="section.number" select="$section.number"/>
          </xsl:call-template>
        </dlg:page-frame>
        <dlg:paper-type>
          <xsl:call-template name="apply.paper.type.props"/>
        </dlg:paper-type>
        <dlg:objects>
          <xsl:choose>
            <xsl:when test="./w:headerReference[@w:type='default' or not(attribute::w:type)]">
              <xsl:apply-templates mode="pages" select="./w:headerReference[@w:type='default' or not(attribute::w:type)]">
                <xsl:with-param name="topMargin" select="$topMargin"/>
                <xsl:with-param name="leftMargin" select="$leftMargin"/>
                <xsl:with-param name="rightMargin" select="$rightMargin"/>
                <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
                <xsl:with-param name="pageHeight" select="$pageHeight"/>
                <xsl:with-param name="pageWidth" select="$pageWidth"/>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates mode="apply.prior.header" select="preceding::w:headerReference[1]">
                <xsl:with-param name="topMargin" select="$topMargin"/>
                <xsl:with-param name="leftMargin" select="$leftMargin"/>
                <xsl:with-param name="rightMargin" select="$rightMargin"/>
                <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
                <xsl:with-param name="pageHeight" select="$pageHeight"/>
                <xsl:with-param name="pageWidth" select="$pageWidth"/>
              </xsl:apply-templates>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:choose>
            <xsl:when test="./w:footerReference[@w:type='default' or not(attribute::w:type)]">
              <xsl:apply-templates mode="pages" select="./w:footerReference[@w:type='default' or not(attribute::w:type)]">
                <xsl:with-param name="topMargin" select="$topMargin"/>
                <xsl:with-param name="leftMargin" select="$leftMargin"/>
                <xsl:with-param name="rightMargin" select="$rightMargin"/>
                <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
                <xsl:with-param name="pageHeight" select="$pageHeight"/>
                <xsl:with-param name="pageWidth" select="$pageWidth"/>
              </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
              <xsl:apply-templates mode="apply.prior.footer" select="preceding::w:footerReference[1]">
                <xsl:with-param name="topMargin" select="$topMargin"/>
                <xsl:with-param name="leftMargin" select="$leftMargin"/>
                <xsl:with-param name="rightMargin" select="$rightMargin"/>
                <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
                <xsl:with-param name="pageHeight" select="$pageHeight"/>
                <xsl:with-param name="pageWidth" select="$pageWidth"/>
              </xsl:apply-templates>
            </xsl:otherwise>
          </xsl:choose>
          <xsl:if test="$generateTOC = 'true' and not(preceding::w:sectPr)">
            <xsl:apply-templates mode="generateTOC" select="//w:instrText[contains(string(.), 'TOC ')]"/>
          </xsl:if>
        </dlg:objects>
      </dlg:page>
    </dlg:doc-message-use>
  </xsl:template>

  <xsl:template mode="apply.prior.header" match="w:headerReference">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:choose>
      <xsl:when test="@w:type='default' or not(attribute::w:type)">
        <xsl:apply-templates mode="pages" select=".">
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="apply.prior.header" select="preceding::w:headerReference[1]">
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="apply.prior.footer" match="w:footerReference">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:choose>
      <xsl:when test="@w:type='default' or not(attribute::w:type)">
        <xsl:apply-templates mode="pages" select=".">
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="apply.prior.footer" select="preceding::w:footerReference[1]">
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="pages" match="w:headerReference">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <dlg:text>
      <xsl:call-template name="apply.header.props"/>
      <fo:flow>
        <xsl:variable name="doc.part.name1" select="concat('/word/_rels/', key('key.doc.rels', @r:id)/@Target)"/>
        <xsl:variable name="doc.part.name2" select="concat($doc.part.name1, '.rels')"/>
        <xsl:variable name="header.part.name" select="concat('/word/', key('key.doc.rels', @r:id)/@Target)"/>
        <xsl:apply-templates select="/pkg:package/pkg:part[@pkg:name=$header.part.name]/pkg:xmlData/*">
          <xsl:with-param name="doc.part.rels" select="$doc.part.name2"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </fo:flow>
    </dlg:text>
  </xsl:template>

  <xsl:template mode="pages" match="w:footerReference">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <dlg:text>
      <xsl:call-template name="apply.footer.props"/>
      <fo:flow>
        <xsl:variable name="doc.part.name1" select="concat('/word/_rels/', key('key.doc.rels', @r:id)/@Target)"/>
        <xsl:variable name="doc.part.name2" select="concat($doc.part.name1, '.rels')"/>
        <xsl:variable name="footer.part.name" select="concat('/word/', key('key.doc.rels', @r:id)/@Target)"/>
        <xsl:apply-templates select="/pkg:package/pkg:part[@pkg:name=$footer.part.name]/pkg:xmlData/*">
          <xsl:with-param name="doc.part.rels" select="$doc.part.name2"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </fo:flow>
    </dlg:text>
  </xsl:template>

  <xsl:template match="w:hdr|w:ftr">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="doc.part.rels"/>
    <xsl:for-each select="w:p|w:tbl|w:fldSimple|w:sdt">
      <xsl:choose>
        <xsl:when test="name() = 'w:tbl'">
          <xsl:apply-templates select=".">
            <xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
            <xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
            <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
            <xsl:with-param name="is.header.footer" select="'true'"/>
            <xsl:with-param name="topMargin" select="$topMargin"/>
            <xsl:with-param name="leftMargin" select="$leftMargin"/>
            <xsl:with-param name="rightMargin" select="$rightMargin"/>
            <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
            <xsl:with-param name="pageHeight" select="$pageHeight"/>
            <xsl:with-param name="pageWidth" select="$pageWidth"/>
          </xsl:apply-templates>
        </xsl:when>
        <xsl:when test="name() = 'w:p'">
          <fo:block>
            <xsl:call-template name="apply.block.props"/>
            <xsl:apply-templates select="*[not(self::w:sectPr)]">
              <xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
              <xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
              <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
              <xsl:with-param name="is.header.footer" select="'true'"/>
              <xsl:with-param name="topMargin" select="$topMargin"/>
              <xsl:with-param name="leftMargin" select="$leftMargin"/>
              <xsl:with-param name="rightMargin" select="$rightMargin"/>
              <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
              <xsl:with-param name="pageHeight" select="$pageHeight"/>
              <xsl:with-param name="pageWidth" select="$pageWidth"/>
            </xsl:apply-templates>
          </fo:block>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="./*">
            <xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
            <xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
            <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
            <xsl:with-param name="is.header.footer" select="'true'"/>
            <xsl:with-param name="topMargin" select="$topMargin"/>
            <xsl:with-param name="leftMargin" select="$leftMargin"/>
            <xsl:with-param name="rightMargin" select="$rightMargin"/>
            <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
            <xsl:with-param name="pageHeight" select="$pageHeight"/>
            <xsl:with-param name="pageWidth" select="$pageWidth"/>
          </xsl:apply-templates>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each>
  </xsl:template>

  <xsl:template name="apply.message.use.props">
    <xsl:param name="section.number"/>
    <xsl:attribute name="page-positions">as-placed</xsl:attribute>
    <xsl:attribute name="page-number">0</xsl:attribute>
    <xsl:attribute name="message">
      <xsl:text>Page|</xsl:text>
      <xsl:value-of select="$section.number"/>
      <xsl:text>|DOCX</xsl:text>
    </xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.page.props">
    <xsl:attribute name="flow-type">repeat</xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.page.frame.props">
    <xsl:param name="section.number"/>
    <xsl:attribute name="can-be-table">true</xsl:attribute>
    <xsl:attribute name="can-be-toc">true</xsl:attribute>
    <xsl:attribute name="named-flow">
      <xsl:text>m_scopedNamedFlow|</xsl:text>
      <xsl:value-of select="$section.number"/>
      <xsl:text>|Flow_</xsl:text>
      <xsl:value-of select="$section.number"/>
    </xsl:attribute>
    <xsl:attribute name="rect">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgMar/@w:top"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgMar/@w:left"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:h - w:pgMar/@w:bottom"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:w - w:pgMar/@w:right"/>
      </xsl:call-template>
    </xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.footnote.frame.props">
    <xsl:attribute name="allow-smaller">true</xsl:attribute>
    <xsl:attribute name="flow-control">all</xsl:attribute>
    <xsl:attribute name="have-footnote">pageonly</xsl:attribute>
    <xsl:attribute name="offset-frame-line">150</xsl:attribute>
    <xsl:attribute name="hide-margin">250</xsl:attribute>
    <xsl:attribute name="multiple-messages">true</xsl:attribute>
    <xsl:attribute name="can-split">false</xsl:attribute>
    <xsl:attribute name="frame-line-style">none</xsl:attribute>
    <xsl:attribute name="frame-style">4</xsl:attribute>
    <xsl:attribute name="wt-frame-line-style">10</xsl:attribute>
    <xsl:attribute name="rect">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:h - w:pgMar/@w:bottom - 144"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgMar/@w:left"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:h - w:pgMar/@w:bottom"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:w - w:pgMar/@w:right"/>
      </xsl:call-template>
    </xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.paper.type.props">
    <xsl:attribute name="size">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:w"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:h"/>
      </xsl:call-template>
      <xsl:text> </xsl:text>
    </xsl:attribute>
  </xsl:template>

  <xsl:template name="make.section">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="section.number"/>
    <dlg:section>
      <xsl:call-template name="apply.section.props">
        <xsl:with-param name="section.number" select="$section.number"/>
      </xsl:call-template>
      <dlg:paragraph>
        <xsl:call-template name="apply.paragraph.props"/>
        <dlg:message-content>
          <dlg:object>
            <dlg:text>
              <xsl:call-template name="apply.text.props"/>
              <fo:flow>
                <xsl:call-template name="apply.flowing.flow.props"/>
                <xsl:call-template name="create.one.section">
                  <xsl:with-param name="placeAfterTOC" select="'true'"/>
                  <xsl:with-param name="topMargin" select="$topMargin"/>
                  <xsl:with-param name="leftMargin" select="$leftMargin"/>
                  <xsl:with-param name="rightMargin" select="$rightMargin"/>
                  <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
                  <xsl:with-param name="pageHeight" select="$pageHeight"/>
                  <xsl:with-param name="pageWidth" select="$pageWidth"/>
                </xsl:call-template>
              </fo:flow>
            </dlg:text>
          </dlg:object>
        </dlg:message-content>
      </dlg:paragraph>
    </dlg:section>
  </xsl:template>

  <xsl:template name="create.one.section">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="placeAfterTOC"/>
    <xsl:choose>
      <xsl:when test="ancestor::w:p">
        <xsl:apply-templates mode="section.walk.back" select="../../preceding-sibling::*[1]">
          <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
				<xsl:if test="$placeAfterTOC = 'true' and ancestor::w:p/w:r">
					<xsl:apply-templates select="ancestor::w:p">
						<xsl:with-param name="topMargin" select="$topMargin"/>
						<xsl:with-param name="leftMargin" select="$leftMargin"/>
						<xsl:with-param name="rightMargin" select="$rightMargin"/>
						<xsl:with-param name="bottomMargin" select="$bottomMargin"/>
						<xsl:with-param name="pageHeight" select="$pageHeight"/>
						<xsl:with-param name="pageWidth" select="$pageWidth"/>
					</xsl:apply-templates>
				</xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="section.walk.back" select="preceding-sibling::*[1]">
          <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="self::w:p|self::w:tbl|self::w:sdt|self::w:fldSimple">
      <xsl:apply-templates select=".">
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
      </xsl:apply-templates>
    </xsl:if>
    <xsl:choose>
      <xsl:when test="ancestor::w:p">
        <xsl:apply-templates mode="section.walk.ahead" select="../../following-sibling::*[1]">
          <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates mode="section.walk.ahead" select="following-sibling::*[1]">
          <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="section.walk.back" match="*">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="placeAfterTOC"/>
    <xsl:variable name="finished">
      <xsl:choose>
        <xsl:when test="$placeAfterTOC = 'true' and count(preceding::w:fldChar) &lt; $endOfTOC">true</xsl:when>
        <xsl:when test="self::w:p/w:pPr/w:sectPr|self::w:sectPr">true</xsl:when>
        <xsl:otherwise>false</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$finished='false'">
      <xsl:apply-templates mode="section.walk.back" select="preceding-sibling::*[1]">
        <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
      </xsl:apply-templates>
      <xsl:apply-templates select=".">
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
      </xsl:apply-templates>
    </xsl:if>
  </xsl:template>

  <xsl:template mode="section.walk.ahead" match="*">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="placeAfterTOC"/>
    <xsl:variable name="finished">
      <xsl:choose>
        <xsl:when test="$placeAfterTOC = 'true' and count(preceding::w:fldChar) &lt; $endOfTOC">true</xsl:when>
        <xsl:when test="following::w:sectPr[1]/w:type/@w:val='continuous'">false</xsl:when>
        <xsl:otherwise>true</xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$finished='false'">
      <xsl:apply-templates select=".">
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
      </xsl:apply-templates>
      <xsl:apply-templates mode="section.walk.ahead" select="following-sibling::*[1]">
        <xsl:with-param name="placeAfterTOC" select="$placeAfterTOC"/>
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
      </xsl:apply-templates>
    </xsl:if>
  </xsl:template>

  <xsl:template name="apply.document.props">
    <xsl:attribute name="document-type">normal</xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.section.props">
    <xsl:param name="section.number"/>
    <xsl:attribute name="flow-target-type">any</xsl:attribute>
    <xsl:attribute name="design-page">
      <xsl:text>Page|</xsl:text>
      <xsl:value-of select="$section.number"/>
      <xsl:text>|DOCX</xsl:text>
    </xsl:attribute>
    <xsl:attribute name="flow-target-type">named</xsl:attribute>
    <xsl:attribute name="named-flow">
      <xsl:text>Flow|</xsl:text>
      <xsl:value-of select="$section.number"/>
      <xsl:text>|Flow_</xsl:text>
      <xsl:value-of select="$section.number"/>
    </xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.paragraph.props">
    <xsl:attribute name="can-split-text">true</xsl:attribute>
  </xsl:template>

  <xsl:template name="apply.text.props">
  </xsl:template>

  <xsl:template name="apply.header.props">
    <xsl:attribute name="v-auto-size">true</xsl:attribute>
    <xsl:attribute name="ignore-relative">ignore</xsl:attribute>
    <xsl:attribute name="size-maximum">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="../w:pgMar/@w:top"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:attribute name="docx-part">header</xsl:attribute>
    <dlg:rect>
      <xsl:attribute name="top">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgMar/@w:header"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="left">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgMar/@w:left"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="right">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgSz/@w:w - ../w:pgMar/@w:right"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="bottom">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgMar/@w:top"/>
        </xsl:call-template>
      </xsl:attribute>
    </dlg:rect>
  </xsl:template>

  <xsl:template name="apply.footer.props">
    <xsl:attribute name="v-auto-size">true</xsl:attribute>
    <xsl:attribute name="ignore-relative">ignore</xsl:attribute>
    <xsl:attribute name="anchor">bl</xsl:attribute>
    <xsl:attribute name="size-maximum">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="../w:pgSz/@w:h - ../w:pgMar/@w:footer"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:attribute name="docx-part">footer</xsl:attribute>
    <dlg:rect>
      <xsl:attribute name="top">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgSz/@w:h - ../w:pgMar/@w:bottom"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="left">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgMar/@w:left"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="right">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgSz/@w:w - ../w:pgMar/@w:right"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="bottom">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="../w:pgSz/@w:h - ../w:pgMar/@w:footer"/>
        </xsl:call-template>
      </xsl:attribute>
    </dlg:rect>
  </xsl:template>

  <xsl:template mode="apply.TOC.properties" match="w:sectPr">
    <xsl:param name="firstOnPage" select="'true'"/>
    <xsl:attribute name="page-flow-limit">
      <xsl:call-template name="convert.resolution">
        <xsl:with-param name="res.from" select="w:pgSz/@w:h - w:pgMar/@w:bottom"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:attribute name="dynamic">1</xsl:attribute>
    <dlg:rect>
      <xsl:choose>
        <xsl:when test="$firstOnPage = 'true'">
          <xsl:attribute name="top">
            <xsl:call-template name="convert.resolution">
              <xsl:with-param name="res.from" select="w:pgMar/@w:top"/>
            </xsl:call-template>
          </xsl:attribute>
          <xsl:attribute name="bottom">
            <xsl:call-template name="convert.resolution">
              <xsl:with-param name="res.from" select="w:pgMar/@w:top + 144"/>
            </xsl:call-template>
          </xsl:attribute>
        </xsl:when>
        <xsl:otherwise>
          <xsl:attribute name="top">
            <xsl:call-template name="convert.resolution">
              <xsl:with-param name="res.from" select="w:pgMar/@w:top + 154"/>
            </xsl:call-template>
          </xsl:attribute>
          <xsl:attribute name="bottom">
            <xsl:call-template name="convert.resolution">
              <xsl:with-param name="res.from" select="w:pgSz/@w:h - w:pgMar/@w:bottom"/>
            </xsl:call-template>
          </xsl:attribute>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:attribute name="left">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="w:pgMar/@w:left"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="right">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="w:pgSz/@w:w - w:pgMar/@w:right"/>
        </xsl:call-template>
      </xsl:attribute>
    </dlg:rect>
  </xsl:template>

  <xsl:template name="apply.flowing.flow.props">
    <xsl:choose>
      <xsl:when test="self::w:p">
        <xsl:apply-templates select="./w:pPr/w:sectPr"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="."/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- ========= End of flowing DOCX placeholder templates ========= -->

  <!-- ========= NON-FLOWING MAIN CONTENT ========= -->
  <xsl:template match="w:document">
    <dlg:dxf-text>
      <xsl:apply-templates select="w:body"/>
    </dlg:dxf-text>
  </xsl:template>

  <xsl:template match="w:body">
		<fo:flow>
			<xsl:call-template name="apply.flow.props"/>
			<xsl:attribute name="display-align">auto</xsl:attribute>

			<xsl:if test="w:sectPr/w:cols and w:sectPr/w:cols/@w:num and w:sectPr/w:cols/@w:num &gt; 1">
				<xsl:message terminate="no">
					<xsl:text>Page columns are not supported by DXF.  Page content will appear in a single column</xsl:text>
				</xsl:message>
			</xsl:if>

			<xsl:apply-templates select="*[not(self::w:sectPr)]">
				<xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
				<xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
			</xsl:apply-templates>
		</fo:flow>
	</xsl:template>

	<xsl:template name="apply.flow.props">
		<xsl:apply-templates select="w:sectPr"/>
	</xsl:template>
	
	<xsl:template match="w:p">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>		
		<xsl:param name="parent.has.sectPr" select="false()"/>			
		<xsl:param name="body.end.indent" select="0"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
		<xsl:param name="doc.part.rels"/>
		<xsl:choose>
			<xsl:when test="m:oMathPara">
				<xsl:apply-templates select="m:oMathPara"/>
			</xsl:when>
			<xsl:when test="w:pPr/w:rPr/w:vanish">
				<xsl:call-template name="add.fo.block">
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>						
					<xsl:with-param name="parent.has.sectPr" select="$parent.has.sectPr"/>						
					<xsl:with-param name="body.end.indent" select="$body.end.indent"/>
					<xsl:with-param name="topMargin" select="$topMargin"/>
					<xsl:with-param name="leftMargin" select="$leftMargin"/>
					<xsl:with-param name="rightMargin" select="$rightMargin"/>
					<xsl:with-param name="bottomMargin" select="$bottomMargin"/>
					<xsl:with-param name="pageHeight" select="$pageHeight"/>
					<xsl:with-param name="pageWidth" select="$pageWidth"/>
					<xsl:with-param name="is.comment" select="1"/>
					<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="add.fo.block">
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>						
					<xsl:with-param name="parent.has.sectPr" select="$parent.has.sectPr"/>						
					<xsl:with-param name="body.end.indent" select="$body.end.indent"/>
					<xsl:with-param name="topMargin" select="$topMargin"/>
					<xsl:with-param name="leftMargin" select="$leftMargin"/>
					<xsl:with-param name="rightMargin" select="$rightMargin"/>
					<xsl:with-param name="bottomMargin" select="$bottomMargin"/>
					<xsl:with-param name="pageHeight" select="$pageHeight"/>
					<xsl:with-param name="pageWidth" select="$pageWidth"/>
          <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
					<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="add.fo.block">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>	
		<xsl:param name="parent.has.sectPr" select="false()"/>		
		<xsl:param name="body.end.indent" select="0"/>
		<xsl:param name="is.comment"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
		<xsl:param name="doc.part.rels"/>
		<fo:block>
			<xsl:call-template name="apply.block.props">
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
				<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
				<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
				<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
				<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
				<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
				<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
				<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
				<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
				<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>						
				<xsl:with-param name="parent.has.sectPr" select="$parent.has.sectPr"/>						
				<xsl:with-param name="body.end.indent" select="$body.end.indent"/>
				<xsl:with-param name="is.comment" select="$is.comment"/>
			</xsl:call-template>
      <xsl:choose>
        <xsl:when test="count(*[not(self::w:pPr)]) > 0">
			    <xsl:apply-templates select="*[not(self::w:pPr)]">
				    <xsl:with-param name="cell" select="$cell"/>
				    <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
				    <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
				    <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
				    <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
				    <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
				    <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
				    <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
				    <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
				    <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
				    <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
            <xsl:with-param name="topMargin" select="$topMargin"/>
            <xsl:with-param name="leftMargin" select="$leftMargin"/>
            <xsl:with-param name="rightMargin" select="$rightMargin"/>
            <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
            <xsl:with-param name="pageHeight" select="$pageHeight"/>
            <xsl:with-param name="pageWidth" select="$pageWidth"/>
            <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
						<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
					</xsl:apply-templates>
        </xsl:when>
        <xsl:otherwise>
          <xsl:call-template name="add.fo.inline.blank">
            <xsl:with-param name="cell" select="$cell"/>
            <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
            <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
            <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
            <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
            <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
            <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
            <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
            <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
            <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
            <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
            <xsl:with-param name="topMargin" select="$topMargin"/>
            <xsl:with-param name="leftMargin" select="$leftMargin"/>
            <xsl:with-param name="rightMargin" select="$rightMargin"/>
            <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
            <xsl:with-param name="pageHeight" select="$pageHeight"/>
            <xsl:with-param name="pageWidth" select="$pageWidth"/>
            <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
						<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
					</xsl:call-template>
        </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="$mustFlow = 'true' and not(descendant::w:r)">
        <fo:inline> </fo:inline>
      </xsl:if>
		</fo:block>		
	</xsl:template>

    <xsl:template match="w:r">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="is.header.footer"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:choose>
			<xsl:when test="w:drawing"> <!-- embedded image -->
        <xsl:apply-templates select="w:drawing">
          <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
          <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
          <xsl:with-param name="topMargin" select="$topMargin"/>
          <xsl:with-param name="leftMargin" select="$leftMargin"/>
          <xsl:with-param name="rightMargin" select="$rightMargin"/>
          <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
          <xsl:with-param name="pageHeight" select="$pageHeight"/>
          <xsl:with-param name="pageWidth" select="$pageWidth"/>
        </xsl:apply-templates>
			</xsl:when>
			<xsl:when test="w:pict"> <!-- embedded shape or text box -->
				<xsl:apply-templates select="w:pict"/>
			</xsl:when>
      <xsl:when test="$mustFlow = 'true' and w:footnoteReference">
        <xsl:apply-templates select="key('key.footnote', w:footnoteReference/@w:id)">
          <xsl:with-param name="cell" select="$cell"/>
          <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
          <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
          <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
          <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
          <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
          <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
          <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
          <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
          <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
          <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="$mustFlow = 'true' and w:endnoteReference">
        <xsl:apply-templates select="key('key.endnote', w:endnoteReference/@w:id)">
          <xsl:with-param name="cell" select="$cell"/>
          <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
          <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
          <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
          <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
          <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
          <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
          <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
          <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
          <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
          <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:when test="w:rPr/w:vanish">
        <xsl:call-template name="add.fo.inline">
          <xsl:with-param name="cell" select="$cell"/>
          <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
          <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
          <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
          <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
          <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
          <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
          <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
          <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
          <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
          <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
          <xsl:with-param name="is.comment" select="1"/>
        </xsl:call-template>
      </xsl:when>
			<xsl:when test="w:sym">
				<xsl:for-each select="w:t|w:sym">
					<fo:inline>
						<xsl:call-template name="apply.inline.props">
							<xsl:with-param name="cell" select="$cell"/>
							<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
							<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
							<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
							<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
							<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
							<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
							<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
							<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
							<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
							<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
						</xsl:call-template>
						<xsl:choose>
							<xsl:when test="self::w:sym">
								<xsl:attribute name="font-family">
									<xsl:value-of select="@w:font"/>
								</xsl:attribute>
								<xsl:attribute name="docx-symbol">
									<xsl:value-of select="@w:char"/>
								</xsl:attribute>
							</xsl:when>
							<xsl:otherwise>
								<xsl:apply-templates select="*[not(self::w:rPr)]">
									<xsl:with-param name="cell" select="$cell"/>
									<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
									<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
									<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
									<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
									<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
									<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
									<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
									<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
									<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
									<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
									<xsl:with-param name="is.comment" select="1"/>
								</xsl:apply-templates>
							</xsl:otherwise>
						</xsl:choose>
					</fo:inline>
				</xsl:for-each>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="add.fo.inline">
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
          <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
        </xsl:call-template> 
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

  <xsl:template match="w:footnote|w:endnote">
    <xsl:param name="cell"/>
    <xsl:param name="num.prev.rows"/>
    <xsl:param name="num.post.rows"/>
    <xsl:param name="num.prev.cols"/>
    <xsl:param name="num.post.cols"/>
    <xsl:param name="do.apply.first.row"/>
    <xsl:param name="do.apply.last.row"/>
    <xsl:param name="do.apply.first.col"/>
    <xsl:param name="do.apply.last.col"/>
    <xsl:param name="do.not.apply.row.banding"/>
    <xsl:param name="do.not.apply.col.banding"/>
    <fo:footnote>
      <xsl:call-template name="apply.footnote.props"/>
      <fo:footnote-body>
        <fo:block>
          <xsl:apply-templates mode="footnote" select="./w:p/w:r/w:t">
            <xsl:with-param name="cell" select="$cell"/>
            <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
            <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
            <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
            <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
            <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
            <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
            <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
            <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
            <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
            <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
          </xsl:apply-templates>
        </fo:block>
      </fo:footnote-body>
    </fo:footnote>
  </xsl:template>

  <xsl:template name="apply.footnote.props">
    <xsl:attribute name="content">text</xsl:attribute>
  </xsl:template>

  <xsl:template match="w:t" mode="footnote">
    <xsl:value-of select="."/>
  </xsl:template>
	
	<xsl:template name="add.fo.inline">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:param name="is.comment"/>
    <xsl:param name="is.header.footer"/>
    <fo:inline>
			<xsl:call-template name="apply.inline.props">
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
				<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
				<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
				<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
				<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
				<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
				<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
				<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
				<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
				<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
				<xsl:with-param name="is.comment" select="$is.comment"/>
			</xsl:call-template>
      <xsl:apply-templates select="*[not(self::w:rPr)]">
   			<xsl:with-param name="cell" select="$cell"/>
    		<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
	    	<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
		    <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
 				<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
   			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
    		<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
	    	<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
		    <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			  <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
  			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      </xsl:apply-templates>
		</fo:inline>	
	</xsl:template>

  <xsl:template name="add.fo.inline.blank">
    <xsl:param name="cell"/>
    <xsl:param name="num.prev.rows"/>
    <xsl:param name="num.post.rows"/>
    <xsl:param name="num.prev.cols"/>
    <xsl:param name="num.post.cols"/>
    <xsl:param name="do.apply.first.row"/>
    <xsl:param name="do.apply.last.row"/>
    <xsl:param name="do.apply.first.col"/>
    <xsl:param name="do.apply.last.col"/>
    <xsl:param name="do.not.apply.row.banding"/>
    <xsl:param name="do.not.apply.col.banding"/>
    <xsl:param name="is.comment"/>
    <xsl:param name="is.header.footer"/>
    <fo:inline>
      <xsl:call-template name="apply.inline.props">
        <xsl:with-param name="cell" select="$cell"/>
        <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
        <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
        <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
        <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
        <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
        <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
        <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
        <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
        <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
        <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        <xsl:with-param name="is.comment" select="$is.comment"/>
      </xsl:call-template>
      <xsl:apply-templates select="w:pPr/w:rPr">
        <xsl:with-param name="cell" select="$cell"/>
        <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
        <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
        <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
        <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
        <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
        <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
        <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
        <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
        <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
        <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      </xsl:apply-templates>
    </fo:inline>
  </xsl:template>
  
	<xsl:template match="w:ptab">
		<xsl:attribute name="text-align">
			<xsl:value-of select="@w:alignment"/>
		</xsl:attribute>
		<xsl:value-of select="string('&#x09;')"/>
	</xsl:template>

	<xsl:template match="w:t">
    <xsl:variable name="useText">
      <xsl:choose>
        <xsl:when test="$mustFlow != 'true'">true</xsl:when>
        <xsl:otherwise>
          <xsl:choose>
            <xsl:when test="../preceding-sibling::w:r/w:fldChar">
              <xsl:call-template name="check.previous.fldChar"/>
            </xsl:when>
            <xsl:otherwise>true</xsl:otherwise>
          </xsl:choose>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$useText = 'true'">
      <xsl:value-of select="string(.)"/>
    </xsl:if>
	</xsl:template>

  <xsl:template name="check.previous.fldChar">
    <xsl:variable name="type">
      <xsl:apply-templates mode="fldChar" select="../preceding-sibling::w:r[1]/w:fldChar"/>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$type = 'separate'">
        <xsl:apply-templates mode="justCheck" select="../preceding::w:instrText[1]"/>
      </xsl:when>
      <xsl:otherwise>true</xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template mode="fldChar" match="w:fldChar">
    <xsl:value-of select="./@w:fldCharType"/>
  </xsl:template>

  <xsl:template mode="justCheck" match="w:instrText">
    <xsl:choose>
      <xsl:when test="contains(., 'NUMPAGES')">false</xsl:when>
      <xsl:when test="contains(., 'PAGE')">false</xsl:when>
      <xsl:otherwise>true</xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="w:instrText">
    <xsl:param name="is.header.footer"/>
    <xsl:choose>
      <xsl:when test="$mustFlow = 'true' and contains(., 'NUMPAGES ')">
        <xsl:text>&lt;SYS_PageTotalPrinted&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$mustFlow = 'true' and contains(., 'PAGE ')">
        <xsl:text>&lt;SYS_PagePrintedValue&gt;</xsl:text>
      </xsl:when>
      <xsl:when test="$generateTOC = 'true' and contains(., 'TOC ')"/>
      <xsl:otherwise>
        <xsl:message terminate="no">
          <xsl:text>Field, Macro or instructional text is not supported and will not print (</xsl:text>
          <xsl:value-of select="string(.)"/>
          <xsl:text>)</xsl:text>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
	</xsl:template>

  <xsl:template match="w:fldSimple">
    <xsl:param name="cell"/>
    <xsl:param name="num.prev.rows"/>
    <xsl:param name="num.post.rows"/>
    <xsl:param name="num.prev.cols"/>
    <xsl:param name="num.post.cols"/>
    <xsl:param name="do.apply.first.row"/>
    <xsl:param name="do.apply.last.row"/>
    <xsl:param name="do.apply.first.col"/>
    <xsl:param name="do.apply.last.col"/>
    <xsl:param name="do.not.apply.row.banding"/>
    <xsl:param name="do.not.apply.col.banding"/>
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="is.header.footer"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:choose>
      <xsl:when test="$mustFlow = 'true' and contains(./@w:instr, 'NUMPAGES ')">
        <fo:inline>
          <xsl:call-template name="apply.inline.props">
            <xsl:with-param name="cell" select="$cell"/>
            <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
            <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
            <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
            <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
            <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
            <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
            <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
            <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
            <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
            <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
          </xsl:call-template>
          <xsl:text>&lt;SYS_PageTotalPrinted&gt;</xsl:text>
        </fo:inline>
      </xsl:when>
      <xsl:when test="$mustFlow = 'true' and contains(./@w:instr, 'PAGE ')">
        <fo:inline>
          <xsl:call-template name="apply.inline.props">
            <xsl:with-param name="cell" select="$cell"/>
            <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
            <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
            <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
            <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
            <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
            <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
            <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
            <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
            <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
            <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
          </xsl:call-template>
          <xsl:text>&lt;SYS_PagePrintedValue&gt;</xsl:text>
        </fo:inline>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="./*">
          <xsl:with-param name="cell" select="$cell"/>
          <xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
          <xsl:with-param name="num.post.rows" select="$num.post.rows"/>
          <xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
          <xsl:with-param name="num.post.cols" select="$num.post.cols"/>
          <xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
          <xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
          <xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
          <xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
          <xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
          <xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
        </xsl:apply-templates>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="w:tab">
		<xsl:value-of select="string('&#x09;')"/>
	</xsl:template>
	
	<xsl:template match="w:noBreakHyphen">
		<xsl:value-of select="string('-')"/>
	</xsl:template>
	
	<xsl:template match="w:br">
		<xsl:choose>
			<xsl:when test="@w:type = 'column'">
				<xsl:message terminate="no">
					<xsl:text>Column breaks are not supported</xsl:text>
				</xsl:message>
			</xsl:when>
      <xsl:when test="$mustFlow = 'true' and @w:type = 'page'">
        <xsl:attribute name="page-break-before">page</xsl:attribute>
      </xsl:when>
      <xsl:when test="$mustFlow != 'true' and @w:type = 'page'">
        <xsl:message terminate="no">
          <xsl:text>Page breaks are not supported</xsl:text>
        </xsl:message>
      </xsl:when>
      <xsl:otherwise>
				<xsl:value-of select="string('&#13;')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- ========== PROPERTIES ========== -->
	<xsl:template match="w:pPr">
		<xsl:param name="node"/>
		<xsl:apply-templates select="*[not(self::w:pStyle) and not(self::w:numPr) and not(self::w:tabs)]">
			<xsl:with-param name="node" select="$node"/>
		</xsl:apply-templates>
	</xsl:template>

	<!-- list implementation, numbered or bullet -->
	<xsl:template match="w:numPr">
		<xsl:param name="node"/>
		<xsl:param name="parent"/>

		<xsl:attribute name="bullet-font">-1</xsl:attribute>
		
		<xsl:variable name="num.id" select="w:numId/@w:val"/>
		<xsl:choose>
			<xsl:when test="$num.id = 0">
				<xsl:attribute name="list-type">none</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>

				<xsl:variable name="abstract.num.id" select="$numbering/w:num[@w:numId = $num.id]/w:abstractNumId/@w:val"/>
				<!-- in some cases the style won't define the ilvl, in which case assume 0 -->
				<xsl:variable name="lvl.id">
					<xsl:choose>
						<xsl:when test="boolean(w:ilvl)">
							<xsl:value-of select="w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="lvl" select="$numbering/w:abstractNum[@w:abstractNumId = $abstract.num.id]/w:lvl[@w:ilvl = $lvl.id]"/>
				<xsl:variable name="start">
					<xsl:choose>
						<xsl:when test="not($lvl/w:start)">0</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$lvl/w:start/@w:val"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				
				<xsl:variable name="prev.sibling" select="$node/preceding-sibling::w:p[1]"/>
				<xsl:variable name="prev.num.id" select="$prev.sibling/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="prev.abstract.num.id" select="$numbering/w:num[@w:numId = $prev.num.id]/w:abstractNumId/@w:val"/>
				<xsl:variable name="prev.lvl.id">
					<xsl:choose>
						<xsl:when test="boolean($prev.sibling/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$prev.sibling/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="prev.lvl" select="$numbering/w:abstractNum[@w:abstractNumId = $prev.abstract.num.id]/w:lvl[@w:ilvl = $prev.lvl.id]"/>

				<xsl:variable name="next.sibling" select="following-sibling::w:p[1]"/>
				<xsl:variable name="next.num.id" select="$next.sibling/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="next.abstract.num.id" select="$numbering/w:num[@w:numId = $next.num.id]/w:abstractNumId/@w:val"/>
				<xsl:variable name="next.lvl.id">
					<xsl:choose>
						<xsl:when test="boolean($next.sibling/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$next.sibling/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="next.lvl" select="$numbering/w:abstractNum[@w:abstractNumId = $next.abstract.num.id]/w:lvl[@w:ilvl = $next.lvl.id]"/>

				<xsl:variable name="next.next.sibling" select="following-sibling::w:p[2]"/>
				<xsl:variable name="next.next.num.id" select="$next.next.sibling/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="next.next.abstract.num.id" select="$numbering/w:num[@w:numId = $next.next.num.id]/w:abstractNumId/@w:val"/>
				<xsl:variable name="next.next.lvl.id">
					<xsl:choose>
						<xsl:when test="boolean($next.next.sibling/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$next.next.sibling/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="next.next.lvl" select="$numbering/w:abstractNum[@w:abstractNumId = $next.next.abstract.num.id]/w:lvl[@w:ilvl = $next.next.lvl.id]"/>
		
				<xsl:variable name="lvl.text" select="$lvl/w:lvlText/@w:val"/>
		
				<xsl:variable name="num.fmt" select="$lvl/w:numFmt/@w:val"/>
				<xsl:variable name="is.bulleted.list" select="$num.fmt = 'bullet'"/>
				
				<xsl:variable name="lvl.text.simplified">
					<xsl:call-template name="simplify.lvl">
						<xsl:with-param name="lvlText" select="$lvl.text"/>
						<xsl:with-param name="numFmt" select="$num.fmt"/>
					</xsl:call-template>
				</xsl:variable>
				
				<xsl:variable name="list.number.color">
					<xsl:choose>
            <xsl:when test="$lvl/w:rPr/w:color">
              <xsl:choose>
                <xsl:when test="$lvl/w:rPr/w:color/@w:val != 'auto'">
                  <xsl:call-template name="get.rgb.color.from.wcolor">
                    <xsl:with-param name="wcolor" select="$lvl/w:rPr/w:color"/>
                  </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="''"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:when test="$parent/w:pPr/w:rPr/w:color and $parent/w:pPr/w:rPr/w:color/@w:val != 'auto'">
							<xsl:call-template name="get.rgb.color.from.wcolor">
								<xsl:with-param name="wcolor" select="parent::w:pPr/w:rPr/w:color"/>
							</xsl:call-template>
						</xsl:when>
						<!-- The style has a numbering and a color defined, but we only want to use
							 that color if we didn't change the level text from something like
							 'Chapter %1' to '%1', lest we end up with a colored numbered list with
							 numbers like '1.', '2.', '3.', etc. -->
						<xsl:when test="$lvl.text = $lvl.text.simplified and $parent/w:rPr/w:color and $parent/w:rPr/w:color/@w:val != 'auto'">
							<xsl:call-template name="get.rgb.color.from.wcolor">
								<xsl:with-param name="wcolor" select="$parent/w:rPr/w:color"/>
							</xsl:call-template>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="''"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
        <xsl:if test="$list.number.color != '' and $list.number.color != 'rgb(NaN,NaN,NaN)'">
					<xsl:attribute name="color-bullet">
						<xsl:value-of select="$list.number.color"/>
					</xsl:attribute>
					<xsl:attribute name="user-set-color">true</xsl:attribute>
				</xsl:if>

        <xsl:variable name="list.bullet.size">
          <xsl:choose>
            <xsl:when test="$lvl/w:rPr/w:sz">
              <xsl:value-of select="concat(floor($lvl/w:rPr/w:sz/@w:val div 2), '.00pt')"/>
            </xsl:when>
            <xsl:when test="$parent/w:pPr/w:rPr/w:sz">
              <xsl:value-of select="concat(floor($parent/w:pPr/w:rPr/w:sz/@w:val div 2), '.00pt')"/>
            </xsl:when>
			 <xsl:when test="$lvl/w:rPr/w:szCs">
              <xsl:value-of select="concat(floor($lvl/w:rPr/w:szCs/@w:val div 2), '.00pt')"/>
            </xsl:when>
            <xsl:when test="$parent/w:pPr/w:rPr/w:szCs">
              <xsl:value-of select="concat(floor($parent/w:pPr/w:rPr/w:szCs/@w:val div 2), '.00pt')"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="''"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:if test="$list.bullet.size != ''">
          <xsl:attribute name="bullet-font-size">
            <xsl:value-of select="$list.bullet.size"/>
          </xsl:attribute>
          <xsl:attribute name="user-set-color">true</xsl:attribute>
        </xsl:if>

        <xsl:variable name="number-type">
					<xsl:call-template name="numFmtAndLvlText2number-type">
						<xsl:with-param name="numFmt" select="$num.fmt"/>
						<xsl:with-param name="lvlText" select="$lvl.text"/>
					</xsl:call-template>			
				</xsl:variable>
				<xsl:attribute name="number-type">
					<xsl:value-of select="$number-type"/>
				</xsl:attribute>				
				
				
				<!-- apply number level properties -->
				<xsl:apply-templates select="$lvl">
					<xsl:with-param name="abstract_num_id" select="$abstract.num.id"/>
					<xsl:with-param name="num_id" select="$num.id"/>
					<xsl:with-param name="next_lvl" select="$next.lvl"/>
					<xsl:with-param name="next_next_lvl" select="$next.next.lvl"/>
				</xsl:apply-templates>		
				
				<!-- if we are in a style node, the number-value will just be the previous $node/w:p's with the same style 
				 	select all previous nodes that use a pStyle (only ones we care about)
					1) pStyle = prev.pStyle ==> recurse(count++)
					2) pStyle num > prev.pStyle ==> recurse(count)
					3) pStyle num < prev.pStyle ==> exit, return count
					4) no more p's with pStyles found ==> exit, return count
				-->
				
				<xsl:variable name="prev.lvl.count">
					<xsl:choose>
						<!-- if we are in a p node, the number-value will just be the previous w:p's with the same num id 
							1) numId = prev.numId ==> recurse(count++)
							2) numId > prev.numId ==> recurse(count)
							3) numId < prev.numId ==> exit, return count
							4) no more p's with numIds found ==> exit, return count
						-->
						<xsl:when test="$node = $parent">
							<xsl:call-template name="count.prev.num.lvls">
								<xsl:with-param name="count" select="$start"/>
								<xsl:with-param name="node" select="$node"/>
								<xsl:with-param name="num.id" select="$num.id"/>
								<xsl:with-param name="ilvl" select="$lvl.id"/>
							</xsl:call-template>
						</xsl:when>
						<!-- if we are in a style node, the number-value will just be the previous $node/w:p's with the same style 
							select all previous nodes that use a pStyle (only ones we care about)
							1) pStyle = prev.pStyle ==> recurse(count++)
							2) pStyle num > prev.pStyle ==> recurse(count)
							3) pStyle num < prev.pStyle ==> exit, return count
							4) no more p's with pStyles found ==> exit, return count
						-->						
						<xsl:otherwise>
							<xsl:call-template name="count.prev.style.lvls">
								<xsl:with-param name="count" select="$start"/>
								<xsl:with-param name="node" select="$node"/>
								<xsl:with-param name="style.id" select="$parent/@w:styleId"/>
							</xsl:call-template>
						</xsl:otherwise>
					</xsl:choose>					
				</xsl:variable>

				<xsl:if test="$number-type != 'bullet'">
				
					<xsl:variable name="number-value">
						<xsl:value-of select="$prev.lvl.count"/>
					</xsl:variable>
			
					<xsl:variable name="number-string">
						<xsl:call-template name="numValAndNumType2numStr">
							<xsl:with-param name="number-type" select="$number-type"/>
							<xsl:with-param name="number-value" select="$number-value"/>
						</xsl:call-template>
					</xsl:variable>		
				
					<xsl:attribute name="user-set-number">
						<xsl:choose>
							<xsl:when test="$number-string != '' and $number-value != ''">restart</xsl:when>
							<xsl:otherwise>
								<!-- determine whether we need to restart numbering -->
								<!-- select the most recent w:p with numbering -->
								<!--we must select the w:p set in order to preserve ordering;
								if you | the style numIds with the p numIds, then style numId is always at the end
								because the styles.xml section is below the content section in the opc xml-->
								<xsl:variable name="mru_numbered_p" select="($node/preceding-sibling::w:p[w:pPr/w:pStyle/@w:val = $styles/w:style[w:pPr/w:numPr/w:numId/@w:val]/@w:styleId]|$node/preceding-sibling::w:p[w:pPr/w:numPr/w:numId/@w:val])[last()]"/>
								<xsl:variable name="mru_numId">
									<xsl:choose>
										<xsl:when test="not(boolean($mru_numbered_p))"/>
										<xsl:when test="boolean($mru_numbered_p/w:pPr/w:numPr/w:numId)">
											<xsl:value-of select="$mru_numbered_p/w:pPr/w:numPr/w:numId/@w:val"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="$styles/w:style[@w:styleId = $mru_numbered_p/w:pPr/w:pStyle/@w:val]/w:pPr/w:numPr/w:numId/@w:val"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:variable name="use_auto_numbering" select="$mru_numId = $num.id"/>			
							
								<xsl:call-template name="get.user.set.number">
									<xsl:with-param name="lvl" select="$lvl"/>
									<xsl:with-param name="num_id" select="$num.id"/>
									<xsl:with-param name="prev_lvl" select="$prev.lvl"/>
									<xsl:with-param name="use_auto_numbering" select="$use_auto_numbering"/>
								</xsl:call-template>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:attribute>
					<xsl:attribute name="number-string">
						<xsl:value-of select="$number-string"/>
					</xsl:attribute>
					<xsl:attribute name="number-value">
						<xsl:value-of select="$number-value"/>
					</xsl:attribute>
				</xsl:if>		
				
				<xsl:attribute name="number-indent">
					<xsl:call-template name="get.number.indent">
						<xsl:with-param name="lvl" select="$lvl"/>
						<xsl:with-param name="num_id" select="$num.id"/>
						<xsl:with-param name="prev_lvl" select="$prev.lvl"/>
					</xsl:call-template>
				</xsl:attribute>		
					
			</xsl:otherwise>
		</xsl:choose>
	
		<xsl:call-template name="apply.indents">
			<xsl:with-param name="mode" select="'tab-ruler'"/>
			<xsl:with-param name="node" select="$parent"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- Count all of the previous matching styles until we get to one that is higher in the hierarchy 
				For ex:
				Heading 2, Heading 2, Heading 3, Heading 2, Heading 1, Heading 2 would return 3
	-->
	<xsl:template name="count.prev.style.lvls">
		<xsl:param name="count" select="number(1)"/>
		<xsl:param name="node"/>
		<xsl:param name="style.id"/>
		
		<xsl:variable name="count.prev.style.similar" select="count($node/preceding-sibling::w:p[w:pPr/w:pStyle/@w:val = $style.id])"/>
		<xsl:variable name="prev.p.styled.node" select="$node/preceding-sibling::w:p[w:pPr/w:pStyle/@w:val][1]"/>

		<xsl:choose>
			<!-- no more listed items with a similar style, so that's it -->	
			<!-- no more listed items at all, so that's it -->
			<xsl:when test="not($count.prev.style.similar) or not($prev.p.styled.node)">
				<xsl:value-of select="$count"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="curr.style" select="key('key.styles', $style.id)"/>
				<xsl:variable name="curr.style.num.id" select="$curr.style/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="curr.style.ilvl">
					<xsl:choose>
						<xsl:when test="boolean($curr.style/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$curr.style/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>

				<xsl:variable name="prev.style" select="key('key.styles', $prev.p.styled.node/w:pPr/w:pStyle/@w:val)"/>
				<xsl:variable name="prev.style.num.id" select="$prev.style/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="prev.style.ilvl">
					<xsl:choose>
						<xsl:when test="boolean($prev.style/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$prev.style/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>			
					
				<xsl:choose>
					<!-- the previous list item is a higher-level list (prev.style.numId < style.numId) or ((prev.style.numId = style.numId) and (prev.style.ilvl < curr.style.ilvl)), so that's it -->
					<xsl:when test="($prev.style.num.id &lt; $curr.style.num.id) or (($prev.style.num.id = $curr.style.num.id) and ($prev.style.ilvl &lt; $curr.style.ilvl))">
						<xsl:value-of select="$count"/>
					</xsl:when>
					<!-- the previous list item is equal to what we're looking for, call again with incremented count -->
					<xsl:when test="$prev.p.styled.node/w:pPr/w:pStyle/@w:val = $style.id">
						<xsl:call-template name="count.prev.style.lvls">
							<xsl:with-param name="count" select="$count+1"/>
							<xsl:with-param name="node" select="$prev.p.styled.node"/>
							<xsl:with-param name="style.id" select="$style.id"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="count.prev.style.lvls">
							<xsl:with-param name="count" select="$count"/>
							<xsl:with-param name="node" select="$prev.p.styled.node"/>
							<xsl:with-param name="style.id" select="$style.id"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Count all of the previous matching numbered items until we get to one that is higher in the hierarchy 
				For ex:
				[numId=1; ilvl=1], [numId=1; ilvl=2], [numId=1; ilvl=1], [numId=1; ilvl=1], [numId=1; ilvl=0], would return 3
	-->
	<xsl:template name="count.prev.num.lvls">
		<xsl:param name="count" select="number(1)"/>
		<xsl:param name="node"/>
		<xsl:param name="num.id"/>
		<xsl:param name="ilvl"/>
		
		<xsl:variable name="count.prev.num.similar" select="count($node/preceding-sibling::w:p[w:pPr/w:numPr/w:numId/@w:val = $num.id])"/>
		<xsl:variable name="prev.p.num.node" select="$node/preceding-sibling::w:p[w:pPr/w:numPr/w:numId/@w:val][1]"/>

		<xsl:choose>
			<!-- no more listed items with a similar number, so that's it -->
			<!-- no more listed items at all, so that's it -->
			<xsl:when test="not($count.prev.num.similar) or not($prev.p.num.node)">
				<xsl:value-of select="$count"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="prev.p.num.id" select="$prev.p.num.node/w:pPr/w:numPr/w:numId/@w:val"/>
				<xsl:variable name="prev.p.ilvl">
					<xsl:choose>
						<xsl:when test="boolean($prev.p.num.node/w:pPr/w:numPr/w:ilvl)">
							<xsl:value-of select="$prev.p.num.node/w:pPr/w:numPr/w:ilvl/@w:val"/>
						</xsl:when>
						<xsl:otherwise>0</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:choose>
					<!-- the previous list item is a higher-level list (prev.numId > numId), so that's it -->
					<xsl:when test="($prev.p.num.id &lt; $num.id) or (($prev.p.num.id = $num.id) and ($prev.p.ilvl &lt; $ilvl))">
						<xsl:value-of select="$count"/>			
					</xsl:when>
					<!-- the previous list item is equal to what we're looking for, call again with incremented count -->
					<xsl:when test="($prev.p.num.id = $num.id) and ($prev.p.ilvl = $ilvl)">
						<xsl:call-template name="count.prev.num.lvls">
							<xsl:with-param name="count" select="$count+1"/>
							<xsl:with-param name="node" select="$prev.p.num.node"/>
							<xsl:with-param name="num.id" select="$num.id"/>
							<xsl:with-param name="ilvl" select="$ilvl"/>
						</xsl:call-template>
					</xsl:when>
					<!-- the previous list item is a lower-level list (prev.numId < numId) so call again but don't increment count -->
					<xsl:otherwise>
						<xsl:call-template name="count.prev.num.lvls">
							<xsl:with-param name="count" select="$count"/>
							<xsl:with-param name="node" select="$prev.p.num.node"/>
							<xsl:with-param name="num.id" select="$num.id"/>
							<xsl:with-param name="ilvl" select="$ilvl"/>
						</xsl:call-template>
					</xsl:otherwise>				
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:rPr">
    <xsl:param name="doc.defaults"/>
    <xsl:apply-templates select="*[not(self::w:rStyle)]">
      <xsl:with-param name="doc.defaults" select="$doc.defaults"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:sectPr">
		<xsl:apply-templates select="w:pgSz|w:pgMar|w:headerReference|w:footerReference|w:endnotePr"/>
	</xsl:template>
	
	<xsl:template match="w:headerReference">
    <xsl:if test="$mustFlow != 'true'">
      <xsl:message terminate="no">
        <xsl:text>Headers are not supported by DXF</xsl:text>
      </xsl:message>
    </xsl:if>
	</xsl:template>

	<xsl:template match="w:footerReference">
    <xsl:if test="$mustFlow != 'true'">
      <xsl:message terminate="no">
        <xsl:text>Footers are not supported by DXF</xsl:text>
      </xsl:message>
    </xsl:if>
	</xsl:template>

	<xsl:template match="w:endnotePr">
		<xsl:apply-templates select="*[not(self::w:numFmt)]"/>
	</xsl:template>

	<xsl:template name="apply.default.block.props">
		<!-- fo:block attribute defaults -->
		<xsl:attribute name="keep-together">auto</xsl:attribute>
		<xsl:attribute name="keep-with-next">auto</xsl:attribute>
		<xsl:attribute name="text-align">left</xsl:attribute>
		<xsl:attribute name="text-indent">0lu</xsl:attribute>
		<xsl:attribute name="end-indent">0lu</xsl:attribute>
		<xsl:attribute name="line-height">0lu</xsl:attribute>
		<xsl:attribute name="space-before">0lu</xsl:attribute>
		<xsl:attribute name="space-after">0lu</xsl:attribute>
		<xsl:attribute name="start-indent">0lu</xsl:attribute>
		<xsl:attribute name="tab-ruler">-1</xsl:attribute>
		<xsl:attribute name="usage-rule">Rule|0|</xsl:attribute>	
	</xsl:template>

	<xsl:template name="apply.block.props">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:param name="parent.has.sectPr" select="false()"/>
		<xsl:param name="body.end.indent" select="0"/>
		<xsl:param name="is.comment"/>
		<xsl:call-template name="apply.default.block.props"/>
	<xsl:if test="$is.comment = 1">
      <xsl:attribute name="is-comment">true</xsl:attribute>
  	</xsl:if>

		<!--section properties:
		a hack since these should be in the fo:flow element,
		but apparently DXF doesn't support multiple fo:flow elements-->
		<xsl:if test="$mustFlow != 'true' and w:pPr/w:sectPr">
			<xsl:message terminate="no">
				<xsl:text>Page breaks are not supported by DXF.  Flow will continue on the current page</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="w:pPr/w:sectPr/w:lnNumType">
			<xsl:message terminate="no">
				<xsl:text>Line numbers are not supported by DXF.  Use a numbered list instead</xsl:text>
			</xsl:message>
		</xsl:if>

    <xsl:if test="w:pPr/w:pageBreakBefore">
      <xsl:attribute name="page-break-before">always</xsl:attribute>
    </xsl:if>

		<!--xsl:if so that I don't have to rebaseline the world for a hack-->
		<xsl:if test="$parent.has.sectPr">
			<xsl:variable name="next.p.pgMar.right" select="following-sibling::w:p[w:pPr/w:sectPr/w:pgMar][1]/w:pPr/w:sectPr/w:pgMar/@w:right"/>
			<!--Dialogue not honoring fo:flow margin-left and margin-right, so always applying for now-->
			<xsl:attribute name="end-indent">
				<xsl:call-template name="convert.resolution">
					<xsl:with-param name="res.from" select="($next.p.pgMar.right|$body.end.indent)[1]"/>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>
		
		<!-- apply doc default run styles -->
		<xsl:apply-templates select="$defaults.style.doc.pPr">
			<xsl:with-param name="node" select="."/>
		</xsl:apply-templates>
		<!-- apply table styles -->
		<xsl:apply-templates select="key('key.styles', ancestor::w:tbl/w:tblPr/w:tblStyle/@w:val)[@w:type='table']" mode="block">
			<xsl:with-param name="node" select="."/>
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
		</xsl:apply-templates>
		<!-- apply direct paragraph styles -->
		<xsl:choose>
			<xsl:when test="w:pPr/w:pStyle">
				<xsl:apply-templates select="key('key.styles', w:pPr/w:pStyle/@w:val)[@w:type='paragraph']" mode="block">
					<xsl:with-param name="node" select="."/>
				</xsl:apply-templates>
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="$defaults.style.paragraph" mode="block">
					<xsl:with-param name="node" select="."/>
				</xsl:apply-templates>
			</xsl:otherwise>
		</xsl:choose>

		<!-- don't need to apply all lvl para properties, just the start-indent -->
		<xsl:call-template name="apply.indents">
			<xsl:with-param name="mode" select="'block'"/>
		</xsl:call-template>

		<xsl:apply-templates select="w:pPr/*[not(self::w:rPr) and not(self::w:pStyle) and not(self::w:numPr) and not(self::w:sectPr) and not(self::w:tabs)]"/>

		<xsl:call-template name="apply.tab.ruler.props">
			<xsl:with-param name="style" select="key('key.styles', w:pPr/w:pStyle/@w:val)"/>
		</xsl:call-template>

    <xsl:if test="$generateTOC = 'true' and w:r/w:t">
      <xsl:variable name="outlineLevel">
        <xsl:choose>
          <xsl:when test="w:pPr/w:outlineLvl">
            <xsl:value-of select="w:pPr/w:outlineLvl/@w:val"/>
          </xsl:when>
          <xsl:when test="w:pPr/w:pStyle">
            <xsl:apply-templates mode="outlineLevel" select="key('key.styles', w:pPr/w:pStyle/@w:val)"/>
          </xsl:when>
          <xsl:when test="w:r[1]/w:rPr/w:rStyle">
            <xsl:apply-templates mode="outlineLevel" select="key('key.styles', w:r[1]/w:rPr/w:rStyle/@w:val)"/>
          </xsl:when>
          <xsl:otherwise>999</xsl:otherwise>
        </xsl:choose>
      </xsl:variable>
      <xsl:if test="not($outlineLevel &lt; $TOCLevel1 or $outlineLevel &gt; $TOCLevel2)">
        <dlg:table-of-contents-entry>
          <xsl:attribute name="level">
            <xsl:value-of select="$outlineLevel + 1"/>
          </xsl:attribute>
          <xsl:attribute name="source">paragraph</xsl:attribute>
        </dlg:table-of-contents-entry>
      </xsl:if>
    </xsl:if>
  </xsl:template>
	
	<xsl:template name="numValAndNumType2numStr">
		<xsl:param name="number-value"/>
		<xsl:param name="number-type"/>
		
		<xsl:choose>
			<xsl:when test="$number-type = 'alpha-lower'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="a"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, '.')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-lower'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="i"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, '.')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'alpha-upper'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="A"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, '.')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-upper'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="I"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, '.')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'num-paren'">
				<xsl:value-of select="concat($number-value, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'alpha-lower-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="a"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-lower-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="i"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'alpha-upper-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="A"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-upper-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="I"/>
				</xsl:variable>
				<xsl:value-of select="concat($str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'num-double-paren'">
				<xsl:value-of select="concat('(', $number-value, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'alpha-lower-double-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="a"/>
				</xsl:variable>
				<xsl:value-of select="concat('(', $str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-lower-double-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="i"/>
				</xsl:variable>
				<xsl:value-of select="concat('(', $str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'alpha-upper-double-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="A"/>
				</xsl:variable>
				<xsl:value-of select="concat('(', $str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'roman-upper-double-paren'">
				<xsl:variable name="str">
					<xsl:number value="$number-value" format="I"/>
				</xsl:variable>
				<xsl:value-of select="concat('(', $str, ')')"/>
			</xsl:when>
			<xsl:when test="$number-type = 'num-ordinal' and translate($number-value, '0123456789', '') = '' and $number-value &gt; 0">
				<!-- Thanks to http://stackoverflow.com/questions/1202581/how-to-transform-a-number-1-2-3-etc-into-an-ordinal-number-1st-2nd-3rd-etc -->
				<xsl:variable name="mod100" select="$number-value mod 100" />
				<xsl:variable name="mod10"  select="$number-value mod 10" />
				<xsl:value-of select="$number-value"/>
				<xsl:choose>
					<xsl:when test="$mod100 = 11 or $mod100 = 12 or $mod100 = 13">
						<xsl:text>th</xsl:text>
					</xsl:when>
					<xsl:when test="$mod10 = 1">
						<xsl:text>st</xsl:text>
					</xsl:when>
					<xsl:when test="$mod10 = 2">
						<xsl:text>nd</xsl:text>
					</xsl:when>
					<xsl:when test="$mod10 = 3">
						<xsl:text>rd</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text>th</xsl:text>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<!-- TODO: support text-upper | text-mixed | text-lower -->
			<xsl:otherwise>
				<xsl:value-of select="concat($number-value, '.')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="get.number.indent">
		<xsl:param name="lvl"/>
		<xsl:param name="prev_lvl"/>
		<xsl:param name="num_id"/>
	
		<!-- Translate docx's 0-based level ID into a 1-based DXF number-indent.
			 From ECMA spec on ilvl:  "Specifies the numbering level definition that is
			 to be defined by this set of numbering properties. This override is a
			 zero-based index of the number of list levels in the document. [Example: A
			 value of 2 is the 3rd list level in the document. end example]". -->
		<xsl:variable name="base_number_indent">
			<xsl:choose>
				<xsl:when test="boolean($lvl) and $lvl/@w:ilvl">
					<xsl:value-of select="$lvl/@w:ilvl + 1"/>
				</xsl:when>
				<xsl:otherwise>0</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="lvlText">
			<xsl:choose>
				<xsl:when test="boolean($lvl) and $lvl/w:lvlText">
					<xsl:value-of select="$lvl/w:lvlText/@w:val"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="numFmt">
			<xsl:choose>
				<xsl:when test="boolean($lvl) and $lvl/w:numFmt">
					<xsl:value-of select="$lvl/w:numFmt/@w:val"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:variable name="lvlText_simplified">
			<xsl:call-template name="simplify.lvl">
				<xsl:with-param name="lvlText" select="$lvlText"/>
				<xsl:with-param name="numFmt" select="$numFmt"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:variable name="lvlText_token_count">
			<xsl:call-template name="non-empty.token.count">
				<xsl:with-param name="text">
					<xsl:call-template name="strip-outer-parentheses">
						<xsl:with-param name="text" select="$lvlText_simplified"/>
					</xsl:call-template>
				</xsl:with-param>
				<xsl:with-param name="separator" select="'%'"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:variable name="is_hierarchical" select="$lvlText_token_count &gt; 1"/>
<!-- 
		<xsl:if test="$is_hierarchical and $lvlText = $lvlText_simplified and not($prev_lvl) and not ($prev_numeric_style_lvl)">
			<xsl:message terminate="no">
				<xsl:text>Initial hierarchical numbered list item may have a different number in DXF than Word (e.g., 1.1 in Word might be 1. in DXF)</xsl:text>
			</xsl:message>
		</xsl:if>
-->
		
		<xsl:value-of select="$base_number_indent"/>
	</xsl:template>
	
	<xsl:template name="get.user.set.number">
		<xsl:param name="lvl"/>
		<xsl:param name="prev_lvl"/>
		<xsl:param name="num_id"/>
		<xsl:param name="use_auto_numbering"/>
		<!-- TODO: refactor to use less duplicate code from get.number.indent -->
	
		<xsl:variable name="lvl_id" select="$lvl/@w:ilvl"/>
		<!-- Translate docx's 0-based level ID into a 1-based DXF number-indent.
			 From ECMA spec on ilvl:  "Specifies the numbering level definition that is
			 to be defined by this set of numbering properties. This override is a
			 zero-based index of the number of list levels in the document. [Example: A
			 value of 2 is the 3rd list level in the document. end example]". -->
		<xsl:variable name="base_number_indent">
			<xsl:value-of select="$lvl_id + 1"/>
		</xsl:variable>
		
		<xsl:variable name="lvlText">
			<xsl:value-of select="$lvl/w:lvlText/@w:val"/>
		</xsl:variable>
		
		<xsl:variable name="prev_lvlText">
			<xsl:value-of select="$prev_lvl/w:lvlText/@w:val"/>
		</xsl:variable>
		
		<xsl:variable name="numFmt">
			<xsl:value-of select="$lvl/w:numFmt/@w:val"/>
		</xsl:variable>
		
		<xsl:variable name="prev_numFmt">
			<xsl:value-of select="$prev_lvl/w:numFmt/@w:val"/>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="$prev_lvlText != '' and $prev_numFmt != ''">
				<xsl:variable name="lvlText_simplified">
					<xsl:call-template name="simplify.lvl">
						<xsl:with-param name="lvlText" select="$lvlText"/>
						<xsl:with-param name="numFmt" select="$numFmt"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="lvlText_token_count">
					<xsl:call-template name="non-empty.token.count">
						<xsl:with-param name="text">
							<xsl:call-template name="strip-outer-parentheses">
								<xsl:with-param name="text" select="$lvlText_simplified"/>
							</xsl:call-template>
						</xsl:with-param>
						<xsl:with-param name="separator" select="'%'"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="prevLvlText_simplified">
					<xsl:call-template name="simplify.lvl">
						<xsl:with-param name="lvlText" select="$prev_lvlText"/>
						<xsl:with-param name="numFmt" select="$prev_numFmt"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="prevLvlText_token_count">
					<xsl:call-template name="non-empty.token.count">
						<xsl:with-param name="text">
							<xsl:call-template name="strip-outer-parentheses">
								<xsl:with-param name="text" select="$prevLvlText_simplified"/>
							</xsl:call-template>
						</xsl:with-param>
						<xsl:with-param name="separator" select="'%'"/>
					</xsl:call-template>
				</xsl:variable>
				<!-- If previous level's token count < current level's token count, e.g.,
					 %1. versus %1.%2, then we need to restart numbering. -->
				<xsl:choose>
					<xsl:when test="not(boolean($use_auto_numbering)) or $prevLvlText_token_count &lt; $lvlText_token_count">restart</xsl:when>
					<xsl:otherwise>auto</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="$use_auto_numbering">auto</xsl:when>
			<xsl:otherwise>restart</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<!-- tab ruler -->
	<xsl:template name="apply.tab.ruler.props">
		<xsl:param name="style" select="/.."/>
		
		<dlg:tab-ruler>
			<!-- default properties -->
			<xsl:attribute name="id"></xsl:attribute>
			<xsl:attribute name="user-set-color">false</xsl:attribute>
			<xsl:attribute name="user-set-type">false</xsl:attribute>
			<xsl:attribute name="list-type">none</xsl:attribute>
			
			<xsl:attribute name="number-type">bullet</xsl:attribute>
			<xsl:attribute name="number-indent">0</xsl:attribute>
			
			<!-- dlg:tab-ruler attribute defaults -->
			<xsl:attribute name="default-tab">
				<xsl:value-of select="$default.tab.stop"/>
			</xsl:attribute>
	
			<!-- apply style numbering -->
			<xsl:apply-templates select="key('key.styles', w:pPr/w:pStyle/@w:val)[@w:type='paragraph']" mode="list">
				<xsl:with-param name="node" select="."/>
			</xsl:apply-templates>
			
			<!-- apply direct numbering styles -->
			<xsl:apply-templates select="w:pPr/w:numPr">
				<xsl:with-param name="node" select="."/>
				<xsl:with-param name="parent" select="."/>
			</xsl:apply-templates>
			
			<!--process all tab nodes at once-->
			<xsl:call-template name="processTabs">
				<xsl:with-param name="style" select="$style"/>
				<xsl:with-param name="tabStops" select="w:pPr/w:tabs/w:tab"/>
			</xsl:call-template>
			<!--should w:ptab elements be processed at the same time as regular tabs?-->
			<xsl:if test="w:r/w:ptab">
				<xsl:apply-templates select="w:r/w:ptab" mode="tabs"/>
			</xsl:if>

		</dlg:tab-ruler>
	</xsl:template>

	<!--When I say "walk up", I mean the following direction:
		w:p => w:p's style (style1) => style1's parent style (style2) => ... => root style
		and "walk down" as going the opposite direction as "walk up".-->
	<!--"earlier in the hierarchy" means down the hierarchy since this routine walks up-->
	<xsl:template name="apply.indents">
		<xsl:param name="mode"/>
		<xsl:param name="node" select="."/>
		<xsl:param name="firstLine" select="$node/w:pPr/w:ind/@w:firstLine"/>
		<xsl:param name="hanging" select="$node/w:pPr/w:ind/@w:hanging"/>
		<xsl:param name="left" select="$node/w:pPr/w:ind/@w:left"/>
		<!--17.9.19 numId (Numbering Definition Instance Reference)
		A value of 0 for the val attribute shall never be used to point to a numbering definition instance, and shall
		instead only be used to designate the removal of numbering properties at a particular level in the style hierarchy
		(typically via direct formatting).-->
		<!--numId > 0 => numbering active,
		numId = 0 => numbering removed and disable from here up,
		numId < 0 => numbering was active at one point, but was disabled earlier in the hierarchy-->
		<xsl:param name="numId" select="$node/w:pPr/w:numPr/w:numId/@w:val"/>
		<!--style_id/parentStyle represent either the style referenced by the paragraph,
		or the parent style referenced by a style-->
		<xsl:variable name="style_id">
			<xsl:choose>
				<!--if $node is a style, then get the parent style-->
				<xsl:when test="$node/w:basedOn/@w:val">
					<xsl:value-of select="$node/w:basedOn/@w:val"/>
				</xsl:when>
				<!--else if $node is the paragraph context node, then get the paragraph style-->
				<!--note: ($node=.) doesn't work with XMLSpy here!  So using name($node)='w:p' instead.-->
				<!--apparently you don't walk the style hierarchy if you set numId=0?-->
				<xsl:when test="name($node)='w:p' and w:pPr/w:pStyle/@w:val and not(w:pPr/w:numPr/w:numId/@w:val = 0)">
					<xsl:value-of select="w:pPr/w:pStyle/@w:val"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="parentStyle" select="key('key.styles', $style_id)"/>
		<!--get numbering info-->
		<!--current.numId refers to the numbering definition instance specified by the current node,
		unless the hierarchy disabled numbering at a lower level by setting numId=0.-->
		<xsl:variable name="current.numId">
			<xsl:choose>
				<!--numbering disabled earlier in the hierarchy if $numId <= 0-->
				<xsl:when test="$numId &lt;= 0">
					<xsl:value-of select="$numId"/>
				<!--set previous numId to -numId to indicate that we are numbered closer to the w:p,
				but we should ignore any numbering properties from here up the style hierarchy-->
				</xsl:when>
				<xsl:when test="$numId and ($node/w:pPr/w:numPr/w:numId/@w:val = 0)">
					<xsl:value-of select="-$numId"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$node/w:pPr/w:numPr/w:numId/@w:val"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="num" select="$numbering/w:num[@w:numId = $current.numId]"/>
		<xsl:variable name="abstractNumId" select="$num/w:abstractNumId/@w:val"/>
		<xsl:variable name="abstractNum" select="$numbering/w:abstractNum[@w:abstractNumId = $abstractNumId]"/>
		<xsl:variable name="ilvl">
			<xsl:choose>
				<xsl:when test="$node/w:pPr/w:numPr/w:ilvl/@w:val">
					<xsl:value-of select="$node/w:pPr/w:numPr/w:ilvl/@w:val"/>
				</xsl:when>
				<xsl:otherwise>0</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="num_lvl" select="$num/w:lvlOverride/w:lvl[@w:ilvl = $ilvl]"/>
		<xsl:variable name="abstractNum_lvl" select="$abstractNum/w:lvl[@w:ilvl = $ilvl]"/>
		<!--merge the attributes-->
		<!--precedence = previously found property (e.g., $hanging) > current node's properties > current node's num > current node's abstractNum
			(since we walk from the w:p up the style hierarchy, any previously found property overrides anything at this depth or up)-->
		<xsl:variable name="new.firstLine">
			<xsl:choose>
				<xsl:when test="$firstLine and ($firstLine != '')">
					<xsl:choose>
						<xsl:when test="$firstLine &gt; 0">
							<xsl:value-of select="$firstLine"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:message terminate="no">
								<xsl:text>Negative indentation is not supported. It will be set to 0</xsl:text>
							</xsl:message>
							0
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="$node/w:pPr/w:ind/@w:firstLine">
					<xsl:choose>
						<xsl:when test="$node/w:pPr/w:ind/@w:firstLine &gt; 0">
							<xsl:value-of select="$node/w:pPr/w:ind/@w:firstLine"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:message terminate="no">
								<xsl:text>Negative indentation is not supported. It will be set to 0</xsl:text>
							</xsl:message>
							0
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="$num_lvl/w:pPr/w:ind/@w:firstLine">
					<xsl:value-of select="$num_lvl/w:pPr/w:ind/@w:firstLine"/>
				</xsl:when>
				<xsl:when test="$abstractNum_lvl/w:pPr/w:ind/@w:firstLine">
					<xsl:value-of select="$abstractNum_lvl/w:pPr/w:ind/@w:firstLine"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="new.hanging">
			<xsl:choose>
				<xsl:when test="$hanging and ($hanging != '')">
					<xsl:value-of select="$hanging"/>
				</xsl:when>
				<xsl:when test="$node/w:pPr/w:ind/@w:hanging">
					<xsl:value-of select="$node/w:pPr/w:ind/@w:hanging"/>
				</xsl:when>
				<xsl:when test="$num_lvl/w:pPr/w:ind/@w:hanging">
					<xsl:value-of select="$num_lvl/w:pPr/w:ind/@w:hanging"/>
				</xsl:when>
				<xsl:when test="$abstractNum_lvl/w:pPr/w:ind/@w:hanging">
					<xsl:value-of select="$abstractNum_lvl/w:pPr/w:ind/@w:hanging"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="new.left">
			<xsl:choose>
				<xsl:when test="$left and ($left != '')">
					<xsl:choose>
						<xsl:when test="$left &gt; 0">
							<xsl:value-of select="$left"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:message terminate="no">
								<xsl:text>Negative indentation is not supported. It will be set to 0</xsl:text>
							</xsl:message>
							0
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="$node/w:pPr/w:ind/@w:left">
					<xsl:choose>
						<xsl:when test="$node/w:pPr/w:ind/@w:left &gt; 0">
							<xsl:value-of select="$node/w:pPr/w:ind/@w:left"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:message terminate="no">
								<xsl:text>Negative indentation is not supported. It will be set to 0</xsl:text>
							</xsl:message>
							0
						</xsl:otherwise>
					</xsl:choose>
				</xsl:when>
				<xsl:when test="$num_lvl/w:pPr/w:ind/@w:left">
					<xsl:value-of select="$num_lvl/w:pPr/w:ind/@w:left"/>
				</xsl:when>
				<xsl:when test="$abstractNum_lvl/w:pPr/w:ind/@w:left">
					<xsl:value-of select="$abstractNum_lvl/w:pPr/w:ind/@w:left"/>
				</xsl:when>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="new.numId">
			<xsl:choose>
				<xsl:when test="$current.numId != ''">
					<xsl:value-of select="$current.numId"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$numId"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!--recursion decision-->
		<xsl:choose>
			<!--apparently you don't walk the style hierarchy if you set numId=0?-->
			<xsl:when test="not(boolean($parentStyle)) or ($new.numId &lt;= 0)">
				<!--base case-->
				<xsl:choose>
					<xsl:when test="$mode = 'tab-ruler'">
						<xsl:if test="$new.hanging != ''">
							<xsl:attribute name="default-tab">
								<xsl:call-template name="convert.resolution">
									<xsl:with-param name="res.from" select="$new.hanging"/>
								</xsl:call-template>
							</xsl:attribute>
						</xsl:if>
					</xsl:when>
					<xsl:when test="$mode = 'block'">
						<xsl:variable name="numbered" select="boolean(($new.numId != '') and ($new.numId != 0))"/>
						<xsl:choose>
							<!--hack for Dialogue: if numbered and (left is null or zero), then add artificial space-->
							<xsl:when test="$numbered and (($new.left = '') or ($new.left = 0))">
								<xsl:attribute name="start-indent">
									<xsl:call-template name="convert.resolution">
										<xsl:with-param name="res.from" select="$settings/w:defaultTabStop/@w:val"/>
									</xsl:call-template>
								</xsl:attribute>
							</xsl:when>
							<xsl:when test="($new.left != '')">
								<xsl:attribute name="start-indent">
									<xsl:call-template name="convert.resolution">
										<xsl:with-param name="res.from" select="$new.left"/>
									</xsl:call-template>
								</xsl:attribute>
							</xsl:when>
						</xsl:choose>
						<xsl:if test="not($numbered)">
							<xsl:choose>
								<xsl:when test="($new.firstLine != '')">
									<xsl:attribute name="text-indent">
										<xsl:call-template name="convert.resolution">
											<xsl:with-param name="res.from" select="$new.firstLine"/>
										</xsl:call-template>
									</xsl:attribute>
								</xsl:when>
								<xsl:when test="($new.hanging != '')">
									<xsl:attribute name="text-indent">
										<xsl:choose>
											<xsl:when test="number($new.hanging) = 0">0lu</xsl:when>
											<xsl:otherwise>
												<xsl:call-template name="convert.resolution">
													<xsl:with-param name="res.from" select="-$new.hanging"/>
												</xsl:call-template>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:attribute>
								</xsl:when>
							</xsl:choose>
						</xsl:if>
					</xsl:when>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<!--recurse-->
				<xsl:call-template name="apply.indents">
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="node" select="$parentStyle"/>
					<xsl:with-param name="firstLine" select="$new.firstLine"/>
					<xsl:with-param name="hanging" select="$new.hanging"/>
					<xsl:with-param name="left" select="$new.left"/>
					<xsl:with-param name="numId" select="$new.numId"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="processTabs">
		<xsl:param name="style" select="/.."/>
		<xsl:param name="tabStops" select="/.."/>
		<xsl:variable name="parentStyleNode" select="key('key.styles', $style/w:basedOn/@w:val)"/>
		<xsl:choose>
			<xsl:when test="not($parentStyleNode)">
				<!--base case: process the tab nodes-->
        <xsl:choose>
          <xsl:when test="$revertTabbingCR63521 = 'true'">
            <xsl:call-template name="processTabNodes">
              <xsl:with-param name="tabNodes" select="$tabStops|./w:pPr/w:tabs/w:tab"/>
            </xsl:call-template>
          </xsl:when>
          <xsl:otherwise>
            <xsl:call-template name="processTabNodes">
              <xsl:with-param name="tabNodes" select="$style/w:pPr/w:tabs/w:tab[count($tabStops[@w:pos=$style/w:pPr/w:tabs/w:tab/@w:pos])=0]|$tabStops|./w:pPr/w:tabs/w:tab"/>
            </xsl:call-template>
          </xsl:otherwise>
        </xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<!--recurse-->
				<!--Apparently, you override tab-stop elements with the w:pos attribute;
				so if $tabStops already contains a tab-stop with the same w:pos
				as the current tab-stop, then skip this tab-stop.  (May need to compare other attributes, also?)
				This filter obeys the style hierarchy rules because we add to $tabStops bottom up;
				that is, from the paragraph -> style -> that style's parent style -> ... -> root style.-->
				<xsl:call-template name="processTabs">
					<xsl:with-param name="style" select="$parentStyleNode"/>
					<xsl:with-param name="tabStops" select="$style/w:pPr/w:tabs/w:tab[count($tabStops[@w:pos=$style/w:pPr/w:tabs/w:tab/@w:pos])=0]|$tabStops"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="w:tabs">
		<xsl:call-template name="processTabNodes">
			<xsl:with-param name="tabNodes" select="w:tab"/>
		</xsl:call-template>
	</xsl:template>

	<xsl:template name="processTabNodes">
		<xsl:param name="tabNodes"/>
		<xsl:for-each select="$tabNodes[@w:val != 'clear']">
			<!--Dialogue requires the tab-stop elements to be ordered by tab-indent-->
			<xsl:sort select="@tab-indent"/>
			<dlg:tab-stop>
				<xsl:attribute name="tab-align">
					<xsl:value-of select="@w:val"/>
				</xsl:attribute>
				<xsl:attribute name="tab-indent">
					<xsl:call-template name="convert.resolution">
						<xsl:with-param name="res.from" select="@w:pos"/>
					</xsl:call-template>
				</xsl:attribute>
				<xsl:attribute name="tab-char">
					<xsl:choose>
						<xsl:when test="position()=1 and not(boolean(@w:leader)) and ($tabNodes[@w:leader])[1]">
							<!--From Dialogue code: "Tab (leader) characters are only valid for the first tab"-->
							<xsl:variable name="leader" select="($tabNodes[@w:leader])[1]/@w:leader"/>
							<xsl:choose>
								<xsl:when test="$leader = 'dot'">46</xsl:when>
								<xsl:when test="$leader = 'underscore'">95</xsl:when>
								<xsl:when test="$leader = 'hyphen'">45</xsl:when>
							</xsl:choose>
						</xsl:when>
						<xsl:when test="@w:leader = 'dot'">46</xsl:when>
						<xsl:when test="@w:leader = 'underscore'">95</xsl:when>
						<xsl:when test="@w:leader = 'hyphen'">45</xsl:when>
						<xsl:otherwise></xsl:otherwise>
					</xsl:choose>
				</xsl:attribute>
			</dlg:tab-stop>
		</xsl:for-each>
	</xsl:template>

	<xsl:template match="w:ptab" mode="tabs">
		<xsl:if test="@w:relativeTo = 'margin'">
			<xsl:message terminate="no">Aligning relative to page margins may result in misaligned output</xsl:message>
		</xsl:if>
		<dlg:tab-stop>
			<xsl:attribute name="tab-align">
				<xsl:value-of select="@w:alignment"/>
			</xsl:attribute>
			<xsl:attribute name="tab-indent">
				<xsl:choose>
					<xsl:when test="@w:alignment = 'left' and @w:relativeTo = 'margin'">
						<xsl:call-template name="convert.resolution">
							<xsl:with-param name="res.from" select="ancestor::w:body/w:sectPr/w:pgMar/@w:left"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="@w:alignment = 'right' and @w:relativeTo = 'margin'">
						<xsl:call-template name="convert.resolution">
							<xsl:with-param name="res.from" select="ancestor::w:body/w:sectPr/w:pgSz/@w:w - ancestor::w:body/w:sectPr/w:pgMar/@w:right"/>
						</xsl:call-template>
					</xsl:when>
				</xsl:choose>
			</xsl:attribute>
			<xsl:attribute name="tab-char">
				<xsl:choose>
					<xsl:when test="@w:leader = 'dot'">46</xsl:when>
					<xsl:when test="@w:leader = 'underscore'">95</xsl:when>
					<xsl:when test="@w:leader = 'hyphen'">45</xsl:when>
					<xsl:otherwise></xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</dlg:tab-stop>
	</xsl:template>

	<!-- tab ruler end -->

	<xsl:template name="apply.inline.props">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>		
		<xsl:param name="is.comment"/>
		<xsl:variable name="is.hyperlink" select="parent::w:hyperlink"/>
		<xsl:variable name="is.hyper.toc" select="$is.hyperlink and contains($is.hyperlink/ancestor::w:sdtContent/w:p/w:r/w:instrText, 'TOC')"/>
		<!-- set default properties -->
		<xsl:attribute name="font-style">normal</xsl:attribute>
		<xsl:attribute name="letter-spacing">0.00pt</xsl:attribute>
  	<xsl:if test="$is.comment = 1">
      <xsl:attribute name="is-comment">true</xsl:attribute>
  	</xsl:if>
		<!-- apply doc default run styles -->
    <xsl:apply-templates select="$defaults.style.doc.rPr">
      <xsl:with-param name="doc.defaults" select="'true'"/>
    </xsl:apply-templates>
    <!-- apply table styles -->
		<xsl:apply-templates select="key('key.styles', ancestor::w:tbl/w:tblPr/w:tblStyle/@w:val)[@w:type='table']" mode="inline">
			<xsl:with-param name="node" select="."/>
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>						
		</xsl:apply-templates>
		<!-- apply para style -->
		<xsl:choose>
			<xsl:when test="ancestor::w:p/w:pPr/w:pStyle">
				<xsl:apply-templates select="key('key.styles', ancestor::w:p/w:pPr/w:pStyle/@w:val)[@w:type='paragraph']" mode="inline">
					<xsl:with-param name="node" select="."/>
				</xsl:apply-templates>
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates select="$defaults.style.paragraph" mode="inline">
					<xsl:with-param name="node" select="."/>
				</xsl:apply-templates>
			</xsl:otherwise>
		</xsl:choose>		
		<!-- apply run style when not a TOC hyperlink -->
		<xsl:if test="not($is.hyper.toc and (w:rPr/w:rStyle/@w:val='Hyperlink'))">
			<xsl:choose>
				<xsl:when test="w:rPr/w:rStyle">
					<xsl:apply-templates select="key('key.styles', w:rPr/w:rStyle/@w:val)[@w:type='character']" mode="inline">
						<xsl:with-param name="node" select="."/>
					</xsl:apply-templates>
				</xsl:when>
				<xsl:otherwise>
					<xsl:apply-templates select="$defaults.style.character" mode="inline">
						<xsl:with-param name="node" select="."/>
					</xsl:apply-templates>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:if>
		<!-- apply direct run properties -->
		<xsl:apply-templates select="w:rPr/*[not(self::w:rStyle)]"/>
	</xsl:template>
	
	<xsl:template name="apply.embedded.inline.props">
		<xsl:attribute name="embed-anchor">bottom-left</xsl:attribute>
		<xsl:attribute name="embed-method">inline</xsl:attribute>
		<xsl:attribute name="offset-X">0</xsl:attribute>
		<xsl:attribute name="offset-Y">0</xsl:attribute>
	</xsl:template>

  <xsl:template name="apply.embedded.anchor.props">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
    <xsl:attribute name="docx-anchor">true</xsl:attribute>
    <xsl:attribute name="embed-anchor">
      <xsl:call-template name="construct.anchor"/>
    </xsl:attribute>
    <xsl:attribute name="embed-method">
      <xsl:call-template name="construct.link"/>
    </xsl:attribute>
    <xsl:attribute name="offset-X">
      <xsl:call-template name="get.anchor.x.offset">
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
        <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:attribute name="offset-Y">
      <xsl:call-template name="get.anchor.y.offset">
        <xsl:with-param name="topMargin" select="$topMargin"/>
        <xsl:with-param name="leftMargin" select="$leftMargin"/>
        <xsl:with-param name="rightMargin" select="$rightMargin"/>
        <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
        <xsl:with-param name="pageHeight" select="$pageHeight"/>
        <xsl:with-param name="pageWidth" select="$pageWidth"/>
        <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      </xsl:call-template>
    </xsl:attribute>
    <xsl:if test="wp:positionV/@relativeFrom = 'line'">
      <xsl:attribute name="docx-line-anchor">true</xsl:attribute>
    </xsl:if>
  </xsl:template>

  <xsl:template name="construct.anchor">
    <xsl:variable name="yAnchor">
      <xsl:value-of select="wp:positionV/wp:align"/>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$yAnchor = 'top' or $yAnchor = 'inside'">
        <xsl:text>upper</xsl:text>
      </xsl:when>
      <xsl:when test="$yAnchor = 'center'">
        <xsl:text>center</xsl:text>
      </xsl:when>
      <xsl:when test="$yAnchor = 'bottom' or $yAnchor = 'outside'">
        <xsl:text>bottom</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>upper</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
    
    <xsl:variable name="xAnchor">
      <xsl:value-of select="wp:positionH/wp:align"/>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="$xAnchor = 'left' or $xAnchor = 'inside'">
        <xsl:choose>
          <xsl:when test="wp:positionH/@relativeFrom = 'page'">
            <xsl:text>-right</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>-left</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:when test="$xAnchor = 'center'">
        <xsl:if test="not($yAnchor = 'center')">
          <xsl:text>-center</xsl:text>
        </xsl:if>
      </xsl:when>
      <xsl:when test="$xAnchor = 'outside'">
        <xsl:text>-right</xsl:text>
      </xsl:when>
      <xsl:when test="$xAnchor = 'right'">
        <xsl:choose>
          <xsl:when test="wp:positionH/@relativeFrom = 'page'">
            <xsl:text>-left</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>-right</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:text>-left</xsl:text>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="construct.link">
    <xsl:choose>
      <xsl:when test="wp:positionV/@relativeFrom = 'paragraph' or wp:positionV/@relativeFrom = 'line'">
        <xsl:choose>
          <xsl:when test="wp:positionH/@relativeFrom = 'character'">
            <xsl:text>link</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>link-X</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="wp:positionH/@relativeFrom = 'character'">
            <xsl:text>link-Y</xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text>link-XY</xsl:text>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="get.anchor.x.offset">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
    <xsl:variable name="offsetValue">
      <xsl:choose>
        <xsl:when test=".//wp:positionH/wp14:pctPosHOffset">
          <xsl:variable name="percent">
            <xsl:value-of select=".//wp:positionH/wp14:pctPosHOffset div 100000"/>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test=".//wp:positionH[@relativeFrom = 'margin']/wp14:pctPosHOffset">
              <xsl:variable name="totalWidth" select="$pageWidth - $leftMargin - $rightMargin"/>
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="($totalWidth * $percent) + $leftMargin"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test=".//wp:positionH[@relativeFrom = 'page']/wp14:pctPosHOffset">
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="$pageWidth * $percent"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test=".//wp:positionH[@relativeFrom = 'leftMargin']/wp14:pctPosHOffset
                    or .//wp:positionH[@relativeFrom = 'insideMargin']/wp14:pctPosHOffset">
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="$leftMargin * $percent"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="($pageWidth - $rightMargin) + ($rightMargin * $percent)"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="wp:positionH/wp:posOffset">
          <xsl:variable name="offset">
            <xsl:value-of select="number(wp:positionH/wp:posOffset) div 914.4"/>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="wp:positionH/@relativeFrom = 'character'
                    or wp:positionH/@relativeFrom = 'page'
                    or wp:positionH/@relativeFrom = 'leftMargin'
                    or wp:positionH/@relativeFrom = 'insideMargin'">
              <xsl:value-of select="$offset"/>
            </xsl:when>
            <xsl:when test="wp:positionH/@relativeFrom = 'column'
                    or wp:positionH/@relativeFrom = 'margin'">
              <xsl:variable name="left">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$leftMargin"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:value-of select="$left + $offset"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:variable name="right">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$rightMargin"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:variable name="width">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$pageWidth"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:value-of select="$width - $right + $offset"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'margin' and (string(wp:positionH/wp:align) = 'inside' or string(wp:positionH/wp:align) = 'left'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'page' and string(wp:positionH/wp:align) = 'inside')">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'margin' and (string(wp:positionH/wp:align) = 'outside' or string(wp:positionH/wp:align) = 'right'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth - $rightMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'page' and string(wp:positionH/wp:align) = 'outside')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'margin' and string(wp:positionH/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="(($pageWidth - $rightMargin - $leftMargin) div 2) + $leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'page' and string(wp:positionH/wp:align) = 'left')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'page' and string(wp:positionH/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'page' and string(wp:positionH/wp:align) = 'right')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth - $rightMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'column' and string(wp:positionH/wp:align) = 'left')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'column' and string(wp:positionH/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="(($pageWidth - $rightMargin - $leftMargin) div 2) + $leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'column' and string(wp:positionH/wp:align) = 'right')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth - $rightMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionH/@relativeFrom = 'character')">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'leftMargin' or wp:positionH/@relativeFrom = 'insideMargin') and string(wp:positionH/wp:align) = 'left')">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'leftMargin' or wp:positionH/@relativeFrom = 'insideMargin') and string(wp:positionH/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'leftMargin' or wp:positionH/@relativeFrom = 'insideMargin') and string(wp:positionH/wp:align) = 'right')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'rightMargin' or wp:positionH/@relativeFrom = 'outsideMargin') and string(wp:positionH/wp:align) = 'left')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth - $rightMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'rightMargin' or wp:positionH/@relativeFrom = 'outsideMargin') and string(wp:positionH/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth - ($rightMargin div 2)"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="((wp:positionH/@relativeFrom = 'rightMargin' or wp:positionH/@relativeFrom = 'outsideMargin') and string(wp:positionH/wp:align) = 'right')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageWidth"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>0</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="wp:positionH/@relativeFrom = 'character' or $is.header.footer = 'true'">
        <xsl:value-of select="$offsetValue"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="convertedLeftMargin">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$leftMargin"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$offsetValue - $convertedLeftMargin"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="get.anchor.y.offset">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
    <xsl:variable name="offsetValue">
      <xsl:choose>
        <xsl:when test=".//wp:positionV/wp14:pctPosVOffset">
          <xsl:variable name="percent">
            <xsl:value-of select=".//wp:positionV/wp14:pctPosVOffset div 100000"/>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test=".//wp:positionV[@relativeFrom = 'margin']/wp14:pctPosVOffset">
              <xsl:variable name="totalHeight" select="$pageHeight - $topMargin - $bottomMargin"/>
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="($totalHeight * $percent) + $topMargin"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test=".//wp:positionV[@relativeFrom = 'page']/wp14:pctPosVOffset">
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="$pageHeight * $percent"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test=".//wp:positionV[@relativeFrom = 'topMargin']/wp14:pctPosVOffset
                    or .//wp:positionV[@relativeFrom = 'insideMargin']/wp14:pctPosVOffset
                    or .//wp:positionV[@relativeFrom = 'outsideMargin']/wp14:pctPosVOffset">
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="$topMargin * $percent"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:call-template name="convert.resolution.number">
                <xsl:with-param name="res.from" select="($pageHeight - $bottomMargin) + ($bottomMargin * $percent)"/>
              </xsl:call-template>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="wp:positionV/wp:posOffset">
          <xsl:variable name="offset">
            <xsl:value-of select="number(wp:positionV/wp:posOffset) div 914.4"/>
          </xsl:variable>
          <xsl:choose>
            <xsl:when test="wp:positionV/@relativeFrom = 'paragraph'
                    or wp:positionV/@relativeFrom = 'line'
                    or wp:positionV/@relativeFrom = 'page'
                    or wp:positionV/@relativeFrom = 'topMargin'
                    or wp:positionV/@relativeFrom = 'insideMargin'
                    or wp:positionV/@relativeFrom = 'outsideMargin'">
              <xsl:value-of select="$offset"/>
            </xsl:when>
            <xsl:when test="wp:positionV/@relativeFrom = 'margin'">
              <xsl:variable name="top">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$topMargin"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:value-of select="$top + $offset"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:variable name="bottom">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$bottomMargin"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:variable name="height">
                <xsl:call-template name="convert.resolution.number">
                  <xsl:with-param name="res.from" select="$pageHeight"/>
                </xsl:call-template>
              </xsl:variable>
              <xsl:value-of select="$height - $bottom + $offset"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'margin' and (string(wp:positionV/wp:align) = 'top' or string(wp:positionV/wp:align) = 'inside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'margin' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="(($pageHeight - $topMargin - $bottomMargin) div 2) + $topMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'margin' and string(wp:positionV/wp:align) = 'bottom')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight - $bottomMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'margin' and string(wp:positionV/wp:align) = 'outside')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'page' and string(wp:positionV/wp:align) = 'top')">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'page' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'page' and string(wp:positionV/wp:align) = 'bottom')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'page' and string(wp:positionV/wp:align) = 'inside')">
          <xsl:text>250</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'page' and string(wp:positionV/wp:align) = 'outside')">
          <xsl:variable name="height">
            <xsl:call-template name="convert.resolution.number">
              <xsl:with-param name="res.from" select="$pageHeight"/>
            </xsl:call-template>
          </xsl:variable>
          <xsl:value-of select="$height - 250"/>
        </xsl:when>
        <xsl:when test="wp:positionV/@relativeFrom = 'line'">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'topMargin' and (string(wp:positionV/wp:align) = 'top' or string(wp:positionV/wp:align) = 'inside'))">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'topMargin' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'topMargin' and (string(wp:positionV/wp:align) = 'bottom' or string(wp:positionV/wp:align) = 'outside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'bottomMargin' and (string(wp:positionV/wp:align) = 'top' or string(wp:positionV/wp:align) = 'inside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight - $bottomMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'bottomMargin' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="($pageHeight - ($bottomMargin div 2))"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'bottomMargin' and (string(wp:positionV/wp:align) = 'bottom' or string(wp:positionV/wp:align) = 'outside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$pageHeight"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'insideMargin' and (string(wp:positionV/wp:align) = 'top' or string(wp:positionV/wp:align) = 'inside'))">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'insideMargin' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'insideMargin' and (string(wp:positionV/wp:align) = 'bottom' or string(wp:positionV/wp:align) = 'outside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'outsideMargin' and (string(wp:positionV/wp:align) = 'top' or string(wp:positionV/wp:align) = 'inside'))">
          <xsl:text>0</xsl:text>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'outsideMargin' and string(wp:positionV/wp:align) = 'center')">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin div 2"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:when test="(wp:positionV/@relativeFrom = 'outsideMargin' and (string(wp:positionV/wp:align) = 'bottom' or string(wp:positionV/wp:align) = 'outside'))">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
          <xsl:text>0</xsl:text>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:choose>
      <xsl:when test="wp:positionV/@relativeFrom = 'line' or wp:positionV/@relativeFrom = 'paragraph' or $is.header.footer = 'true'">
        <xsl:value-of select="$offsetValue"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="convertedTopMargin">
          <xsl:call-template name="convert.resolution.number">
            <xsl:with-param name="res.from" select="$topMargin"/>
          </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$offsetValue - $convertedTopMargin"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template name="apply.default.dlg.object.props">
		<xsl:attribute name="can-split">true</xsl:attribute>
		<xsl:attribute name="current-angle">0</xsl:attribute>
		<xsl:attribute name="delay-comp">none</xsl:attribute>
		<xsl:attribute name="flip-h">false</xsl:attribute>
		<xsl:attribute name="flip-v">false</xsl:attribute>
		<xsl:attribute name="flow-around">no</xsl:attribute>
		<xsl:attribute name="flow-break">auto</xsl:attribute>
		<xsl:attribute name="h-auto-size">false</xsl:attribute>
		<xsl:attribute name="ignore-relative">ignore</xsl:attribute>
		<xsl:attribute name="language">Language|0|</xsl:attribute>
		<xsl:attribute name="lock-proportions">false</xsl:attribute>
		<xsl:attribute name="min-height">0</xsl:attribute>
		<xsl:attribute name="pos-rel-to-above">0</xsl:attribute>
		<xsl:attribute name="reference-name">Table</xsl:attribute>
		<xsl:attribute name="shadow">none</xsl:attribute>
		<xsl:attribute name="v-auto-size">false</xsl:attribute>
	</xsl:template>
	
	<!-- ======== TABLE Support ======== -->
	<xsl:template match="w:tbl">
		<xsl:param name="is.header.footer"/>
		<xsl:param name="doc.part.rels"/>
		<fo:block>
			<xsl:call-template name="apply.table.block.props"/>
			<dlg:embedded-object>
				<xsl:call-template name="apply.embedded.inline.props"/>
        <xsl:if test="w:tblPr/w:tblInd and (w:tblPr/w:jc/@w:val = 'left' or not(w:tblPr/w:jc))">
          <xsl:attribute name="offset-X">
            <xsl:call-template name="convert.resolution.number">
              <xsl:with-param name="res.from" select="w:tblPr/w:tblInd/@w:w"/>
            </xsl:call-template>
          </xsl:attribute>
        </xsl:if>
				<dlg:table>
					<xsl:call-template name="apply.table.props"/>
					<xsl:if test="$is.header.footer = 'true'">
						<xsl:attribute name="can-split">false</xsl:attribute>
					</xsl:if>
					<!-- get table look properties now so we don't do it for every cell.. will make things quite slow. -->
					<xsl:variable name="table.look.props.bitmask" select="w:tblPr/w:tblLook/@w:val"/>
					<xsl:variable name="do.apply.first.row">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0020'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="do.apply.last.row">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0040'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="do.apply.first.col">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0080'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="do.apply.last.col">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0100'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="do.not.apply.row.banding">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0200'"/>
						</xsl:call-template>
					</xsl:variable>			
					<xsl:variable name="do.not.apply.col.banding">
						<xsl:call-template name="should.apply.conditional.formatting">
							<xsl:with-param name="bitmask" select="$table.look.props.bitmask"/>
							<xsl:with-param name="value" select="'0400'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:apply-templates select="*[not(self::w:tr)]"/>
					<xsl:apply-templates select="w:tr">
						<xsl:with-param name="do.apply.first.row" select="boolean($do.apply.first.row = 'true')"/>
						<xsl:with-param name="do.apply.last.row" select="boolean($do.apply.last.row = 'true')"/>
						<xsl:with-param name="do.apply.first.col" select="boolean($do.apply.first.col = 'true')"/>
						<xsl:with-param name="do.apply.last.col" select="boolean($do.apply.last.col = 'true')"/>
						<xsl:with-param name="do.not.apply.row.banding" select="boolean($do.not.apply.row.banding = 'true')"/>
						<xsl:with-param name="do.not.apply.col.banding" select="boolean($do.not.apply.col.banding = 'true')"/>
						<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
					</xsl:apply-templates>
				</dlg:table>
			</dlg:embedded-object>
		</fo:block>
	</xsl:template>	

	<xsl:template match="w:tblGrid">
		<xsl:apply-templates select="*"/>
	</xsl:template>

	<xsl:template match="w:tr">
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:param name="doc.part.rels"/>
		<fo:table-row>
			<xsl:attribute name="height">200lu</xsl:attribute> <!-- the line height will be the default table row height -->
			<xsl:variable name="table.props" select="ancestor::w:tbl[1]/w:tblPr"/>
			<xsl:apply-templates select="$defaults.style.table" mode="rows">
				<xsl:with-param name="row" select="."/>
			</xsl:apply-templates>
			<xsl:apply-templates select="key('key.styles', ancestor::w:tbl/w:tblPr/w:tblStyle/@w:val)[@w:type='table']" mode="rows">
				<xsl:with-param name="row" select="."/>
			</xsl:apply-templates>
			<xsl:if test="w:trPr/w:trHeight/@w:val">
				<xsl:attribute name="min-height">
					<xsl:call-template name="convert.resolution">
						<xsl:with-param name="res.from" select="w:trPr/w:trHeight/@w:val"/>
					</xsl:call-template>
				</xsl:attribute>
			</xsl:if>
			<!-- if the row doesn't have any content then set it to a fixed height so it doesn't get reszed to 0 -->
			<xsl:if test="count(descendant::w:t) = 0">
				<xsl:attribute name="fixed-height">true</xsl:attribute>
			</xsl:if>
			<xsl:apply-templates select="w:trPr/*"/>
			<xsl:apply-templates select="w:tc|w:sdt">
				<xsl:with-param name="num.prev.rows" select="count(preceding-sibling::w:tr)"/>
				<xsl:with-param name="num.post.rows" select="count(following-sibling::w:tr)"/>
				<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
				<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
				<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
				<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
				<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
				<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
				<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
			</xsl:apply-templates>
		</fo:table-row>
	</xsl:template>
	
	<xsl:template match="w:tblHeader">
		<xsl:attribute name="row-type">rpt-header</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:gridCol">
		<fo:table-column>
			<xsl:attribute name="column-number">
				<xsl:number count="w:gridCol"/>
			</xsl:attribute>
			<xsl:attribute name="column-width">
				<xsl:call-template name="convert.resolution">
					<xsl:with-param name="res.from" select="@w:w"/>
				</xsl:call-template>
			</xsl:attribute>
		</fo:table-column>
	</xsl:template>	
	
	<xsl:template name="calculate.column.number">
		<xsl:param name="cell"/>
		<xsl:param name="num"/>
		<xsl:variable name="immediate.sibling" select="$cell/preceding-sibling::w:tc[1]"/>
		<xsl:choose>
			<xsl:when test="$immediate.sibling">
				<xsl:choose>
					<xsl:when test="$immediate.sibling/w:tcPr/w:gridSpan">
						<xsl:call-template name="calculate.column.number">
							<xsl:with-param name="cell" select="$immediate.sibling"/>
							<xsl:with-param name="num" select="$num + $immediate.sibling/w:tcPr/w:gridSpan/@w:val"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="calculate.column.number">
							<xsl:with-param name="cell" select="$immediate.sibling"/>
							<xsl:with-param name="num" select="$num + 1"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$num"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:tc">
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:param name="doc.part.rels"/>
		<xsl:if test="(not(w:tcPr/w:hMerge) or w:tcPr/w:hMerge/@w:val='restart') and (not(w:tcPr/w:vMerge) or w:tcPr/w:vMerge/@w:val='restart')">
			<fo:table-cell>
				<xsl:attribute name="number-columns-spanned">1</xsl:attribute>
				<xsl:attribute name="number-rows-spanned">1</xsl:attribute>

        <xsl:choose>
          <xsl:when test="./w:tcPr/w:vAlign/@w:val='center'">
            <xsl:attribute name="display-align">center</xsl:attribute>
          </xsl:when>
          <xsl:when test="./w:tcPr/w:vAlign/@w:val='bottom'">
            <xsl:attribute name="display-align">after</xsl:attribute>
          </xsl:when>
        </xsl:choose>

				<xsl:attribute name="column-number">
					<xsl:call-template name="calculate.column.number">
						<xsl:with-param name="cell" select="."/>
						<xsl:with-param name="num" select="1"/>
					</xsl:call-template>
				</xsl:attribute>
<!--			<xsl:variable name="is.in.first.col" select="count($cell/preceding-sibling::w:tc[ancestor::w:tbl = $cell/ancestor::w:tbl]) = 0"/> -->
<!--			<xsl:variable name="is.in.last.col" select="count($cell/following-sibling::w:tc[ancestor::w:tbl = $cell/ancestor::w:tbl and (not(w:tcPr/w:hMerge) or w:tcPr/w:hMerge/@w:val='restart')]) = 0"/> -->
				<xsl:variable name="num.prev.cols" select="count(preceding-sibling::w:tc)"/>
				<xsl:variable name="num.post.cols" select="count(following-sibling::w:tc)"/>
				<xsl:variable name="is.in.first.row" select="$num.prev.rows=0"/>
				<xsl:variable name="is.in.last.row" select="$num.post.rows=0"/>				
				<xsl:variable name="is.in.first.col" select="$num.prev.cols=0"/>
				<xsl:variable name="is.in.last.col" select="$num.post.cols=0"/>
				<xsl:variable name="table.props" select="ancestor::w:tbl[1]/w:tblPr"/>
				<xsl:if test="../w:trPr/w:trHeight/@w:h-rule = 'exact'">
					<xsl:attribute name="height">
						<xsl:call-template name="convert.resolution">
							<xsl:with-param name="res.from" select="../w:trPr/w:trHeight/@w:val"/>
						</xsl:call-template>
					</xsl:attribute>
				</xsl:if>
				<xsl:apply-templates select="$defaults.style.table" mode="cells">
					<xsl:with-param name="cell" select="."/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
				</xsl:apply-templates>
        <xsl:variable name="table.borders" select="$table.props/w:tblBorders"/>
        <xsl:apply-templates select="key('key.styles', $table.props/w:tblStyle/@w:val)[@w:type='table']" mode="cells">
					<xsl:with-param name="cell" select="."/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
				</xsl:apply-templates>
				<xsl:apply-templates select="$table.props/w:tblBorders/*">
					<xsl:with-param name="cell" select="."/>
					<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
					<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>				
					<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
					<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
        </xsl:apply-templates>				
				<xsl:apply-templates select="$table.props/w:tblCellMar"/>
				<xsl:apply-templates select="w:tcPr">
					<xsl:with-param name="cell" select="."/>
					<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
					<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
					<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
					<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
          <xsl:with-param name="table.borders" select="$table.borders"/>
        </xsl:apply-templates>
				<xsl:apply-templates select="*[not(self::w:tcPr)]">
					<xsl:with-param name="cell" select="."/>
					<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
					<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
					<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
					<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
					<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
					<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
					<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
					<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
					<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
					<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
					<xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
				</xsl:apply-templates>
			</fo:table-cell>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:tblPr">
		<!-- at this point the styles and many other properties are already accounted for, or will be, so don't match -->
		<xsl:apply-templates select="*[not(self::w:tblStyle) and not(self::w:tblCellMar) and not(self::w:tblInd) and not(self::w:jc)]"/>
	</xsl:template>

	<xsl:template match="w:trPr">
		<xsl:apply-templates select="*"/>
	</xsl:template>	
	
	<xsl:template match="w:cantSplit">
		<xsl:choose>
			<xsl:when test="./@val = 'on'">
				<xsl:attribute name="keep-together">always</xsl:attribute>
			</xsl:when>
			<xsl:when test="./@val = 'off'">
				<xsl:attribute name="keep-together">never</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="keep-together">always</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:trHeight">
		<xsl:choose>
			<xsl:when test="@w:val">
				<xsl:attribute name="height">
					<xsl:call-template name="convert.resolution">
						<xsl:with-param name="res.from" select="@w:val"/>
					</xsl:call-template>
				</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="@w:h-rule = 'auto'">
					<xsl:attribute name="height">auto</xsl:attribute>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>	
	
	<xsl:template match="w:tcPr">
		<xsl:param name="cell"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:param name="orient" select="''"/>
		<xsl:apply-templates select="*">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
			<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
			<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
			<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
			<xsl:with-param name="orient" select="$orient"/>
      <xsl:with-param name="table.borders" select="$table.borders"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:cnfStyle">
		<!-- w:cnfStyle is just an optimization property, just ignore -->
	</xsl:template>
	
	<xsl:template match="w:tblInd">
		<dlg:rect>
			<xsl:attribute name="left">
			<xsl:call-template name="convert.table.width.prop">
				<xsl:with-param name="type" select="@w:type"/>
				<xsl:with-param name="value" select="@w:w"/>
			</xsl:call-template>
			</xsl:attribute>
		</dlg:rect>
	</xsl:template>	

	<xsl:template match="w:gridSpan">
		<xsl:attribute name="number-columns-spanned">
			<xsl:value-of select="@w:val"/>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:hMerge">
	  <xsl:if test="@w:val='restart'">
		 <xsl:call-template name="count.cols.spanned">
			<xsl:with-param name="num.cells.spanned" select="1"/>
			<xsl:with-param name="next.cell" select="ancestor::w:tc[1]/following-sibling::w:tc[1]"/>
		 </xsl:call-template>
	  </xsl:if>
	</xsl:template>

	<xsl:template match="w:vMerge">
	  <xsl:if test="@w:val='restart'">
		 <xsl:variable name="col.num" select="count(.|ancestor::w:tc[1]/preceding-sibling::w:tc[not(w:tcPr/w:gridSpan)]) + sum(ancestor::w:tc[1]/preceding-sibling::w:tc/w:tcPr/w:gridSpan/@w:val)"/>
		 <xsl:call-template name="count.rows.spanned">
			<xsl:with-param name="num.cells.spanned" select="1"/>
			<xsl:with-param name="next.cell" select="ancestor::w:tr[1]/following-sibling::w:tr[1]/w:tc[count(.|preceding-sibling::w:tc[not(w:tcPr/w:gridSpan)]) + sum(preceding-sibling::w:tc/w:tcPr/w:gridSpan/@w:val) = $col.num]"/>
			<xsl:with-param name="col.num" select="$col.num"/>
		 </xsl:call-template>
	  </xsl:if>
	</xsl:template>	
	
	<xsl:template match="w:tcW">
		<xsl:param name="cell"/>
		<xsl:attribute name="width">
			<xsl:call-template name="convert.resolution">
				<xsl:with-param name="res.from" select="@w:w"/>
			</xsl:call-template>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:textDirection">
		<xsl:message terminate="no">
			<xsl:text>DXF does not support rotated text or objects specified using "Text Direction"</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="w:tblBorders">
		<xsl:param name="cell"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
		<xsl:if test="$cell">
			<xsl:apply-templates select="*">
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
				<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
				<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
				<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
			</xsl:apply-templates>
		</xsl:if>
	</xsl:template>

	<xsl:template match="w:tblCellMar">
		<xsl:apply-templates select="*" mode="margins"/>
	</xsl:template>	
	
	<xsl:template match="w:tcBorders">
		<xsl:param name="cell"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:param name="orient" select="''"/>
		<xsl:apply-templates select="*">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
			<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
			<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
			<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
			<xsl:with-param name="orient" select="$orient"/>
      <xsl:with-param name="table.borders" select="$table.borders"/>
    </xsl:apply-templates>		
	</xsl:template>
	
	<xsl:template match="w:insideV">
		<xsl:param name="cell"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:param name="orient" select="''"/>
		<xsl:if test="$cell">
			<xsl:variable name="node" select="."/>
			<xsl:call-template name="apply.all.cell.borders">
				<xsl:with-param name="node" select="$node"/>
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="orient" select="'v'"/>
				<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
				<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
				<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
				<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
        <xsl:with-param name="table.borders" select="$table.borders"/>
      </xsl:call-template>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:insideH">
		<xsl:param name="cell"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:param name="orient" select="''"/>
		<xsl:if test="$cell">
			<xsl:variable name="node" select="."/>
			<xsl:call-template name="apply.all.cell.borders">
				<xsl:with-param name="node" select="$node"/>
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="orient" select="'h'"/>
				<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
				<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
				<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
				<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
        <xsl:with-param name="table.borders" select="$table.borders"/>
      </xsl:call-template>
		</xsl:if>
	</xsl:template>

	<xsl:template match="w:top|w:bottom|w:left|w:right">
		<xsl:param name="cell" select="/.."/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:param name="orient" select="''"/>
		<xsl:variable name="override.orient">
			<xsl:choose>
				<xsl:when test="$orient = ''">
					<xsl:value-of select="substring(local-name(),1,1)"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$orient"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="node" select="."/>
		<xsl:if test="$cell">
			<xsl:call-template name="apply.all.cell.borders">
				<xsl:with-param name="node" select="$node"/>
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="orient" select="$override.orient"/>
				<xsl:with-param name="is.in.first.row" select="$is.in.first.row"/>
				<xsl:with-param name="is.in.last.row" select="$is.in.last.row"/>
				<xsl:with-param name="is.in.first.col" select="$is.in.first.col"/>
				<xsl:with-param name="is.in.last.col" select="$is.in.last.col"/>
        <xsl:with-param name="table.borders" select="$table.borders"/>
      </xsl:call-template>		
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:top|w:bottom|w:left|w:right" mode="margins">
		<xsl:attribute name="{concat('margin-',local-name())}">
			<xsl:call-template name="convert.table.width.prop">
				<xsl:with-param name="type" select="@w:type"/>
				<xsl:with-param name="value" select="@w:w"/>
			</xsl:call-template>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template name="apply.table.block.props">
		<xsl:call-template name="apply.default.block.props"/>
		<!-- alignment is a property of the block, not the embed -->
		<xsl:apply-templates select="w:tblPr/w:jc"/>
		<!-- TODO: more table block props? -->
	</xsl:template>

	<xsl:template name="apply.table.props">
		<xsl:call-template name="apply.default.dlg.object.props"/>
		<xsl:attribute name="table-type">auto</xsl:attribute>
		<xsl:attribute name="v-auto-size">true</xsl:attribute>
		<xsl:attribute name="unicode-digits">ascii</xsl:attribute>
		<xsl:attribute name="unicode-script">latin</xsl:attribute>
		<xsl:apply-templates select="$defaults.style.table" mode="table"/>
		<xsl:apply-templates select="key('key.styles', w:tblPr/w:tblStyle/@w:val)[@w:type='table']" mode="table"/>
		<xsl:apply-templates select="w:tblPr/w:tblInd"/>
	</xsl:template>
	
	<xsl:template name="apply.one.border">
		<xsl:param name="node"/>
		<xsl:param name="side"/>
    <xsl:param name="table.borders"/>
    <xsl:variable name="override.border">
      <xsl:choose>
        <xsl:when test="$table.borders">
          <xsl:choose>
            <xsl:when test="$node/@w:val = 'none'">
              <xsl:choose>
                <xsl:when test="$table.borders/*[name($node)]" >
                  <xsl:value-of select="'false'"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:value-of select="'true'"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="'true'"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="'true'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:if test="$override.border = 'true'">
      <xsl:attribute name="border-{$side}-style">
        <xsl:call-template name="convert.border.style">
          <xsl:with-param name="border.style" select="$node/@w:val"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:if test="$node/@w:color">
        <xsl:attribute name="border-{$side}-color">
          <xsl:call-template name="convert.hex.to.color">
            <xsl:with-param name="hex.color" select="$node/@w:color"/>
          </xsl:call-template>
        </xsl:attribute>
      </xsl:if>
      <xsl:if test="$node/@w:sz">
        <xsl:attribute name="border-{$side}-width">
          <xsl:value-of select="concat($node/@w:sz div 16, 'pt')"/>
        </xsl:attribute>
      </xsl:if>
    </xsl:if>
  </xsl:template>
	
	<xsl:template name="apply.all.cell.borders">
		<xsl:param name="node"/>
		<xsl:param name="cell"/>
		<xsl:param name="orient"/>
		<xsl:param name="is.in.first.row"/>
		<xsl:param name="is.in.last.row"/>
		<xsl:param name="is.in.first.col"/>
		<xsl:param name="is.in.last.col"/>
    <xsl:param name="table.borders"/>
    <xsl:if test="$cell">
			<xsl:choose>
				<xsl:when test="$orient='v'">
					<xsl:if test="$cell and count($cell/../w:tc) &gt; 1">
						<xsl:choose>
							<xsl:when test="$is.in.first.col">
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:right/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'right'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:when>
							<xsl:when test="$is.in.last.col">
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:left/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'left'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:when>
							<xsl:otherwise>
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:left/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'left'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:right/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'right'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$orient='h'">
					<xsl:if test="$cell and count($cell/ancestor::w:tbl[1]/w:tr) &gt; 1">
						<xsl:choose>
							<xsl:when test="$is.in.first.row">
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:bottom/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'bottom'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:when>
							<xsl:when test="$is.in.last.row">
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:top/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'top'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:when>
							<xsl:otherwise>
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:bottom/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'bottom'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
								<xsl:if test="not($node/@w:val = 'nil' and not($node/../w:top/@w:val = 'nil'))">
									<xsl:call-template name="apply.one.border">
										<xsl:with-param name="node" select="$node"/>
										<xsl:with-param name="side" select="'top'"/>
                    <xsl:with-param name="table.borders" select="$table.borders"/>
                  </xsl:call-template>
								</xsl:if>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$orient='t'">
					<xsl:if test="name($node/..)='w:tcBorders' or $is.in.first.row">
						<xsl:call-template name="apply.one.border">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="side" select="'top'"/>
              <xsl:with-param name="table.borders" select="$table.borders"/>
            </xsl:call-template>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$orient='b'">
					<xsl:if test="name($node/..)='w:tcBorders' or $is.in.last.row">
						<xsl:call-template name="apply.one.border">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="side" select="'bottom'"/>
              <xsl:with-param name="table.borders" select="$table.borders"/>
            </xsl:call-template>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$orient='l'">
					<xsl:if test="name($node/..)='w:tcBorders' or $is.in.first.col">
						<xsl:call-template name="apply.one.border">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="side" select="'left'"/>
              <xsl:with-param name="table.borders" select="$table.borders"/>
            </xsl:call-template>
					</xsl:if>
				</xsl:when>
				<xsl:when test="$orient='r'">
					<xsl:if test="name($node/..)='w:tcBorders' or $is.in.last.col">
						<xsl:call-template name="apply.one.border">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="side" select="'right'"/>
              <xsl:with-param name="table.borders" select="$table.borders"/>
            </xsl:call-template>
					</xsl:if>
				</xsl:when>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	
	<!-- ========= STYLES ========= -->
	<xsl:template match="w:style">
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)"/>
		<xsl:apply-templates select="w:pPr|w:rPr|w:tblPr"/>
		<xsl:apply-templates select="w:tblStylePr/*[not(self::w:trPr) and not(self::w:tcPr)]"/>
	</xsl:template>
	
	<xsl:template match="w:style" mode="list">
		<xsl:param name="node"/>
		<xsl:apply-templates select="w:pPr/w:numPr">
			<xsl:with-param name="node" select="$node"/>
			<xsl:with-param name="parent" select="."/>
		</xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:style" mode="block">
		<xsl:param name="node"/>
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>		
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="block">
			<xsl:with-param name="node" select="$node"/>
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>			
		</xsl:apply-templates>
		<xsl:apply-templates select="w:pPr">
			<xsl:with-param name="node" select="$node"/>
		</xsl:apply-templates>
		<xsl:if test="$cell">
			<xsl:call-template name="apply.override.table.style">
				<xsl:with-param name="cell" select="$cell"/>
				<xsl:with-param name="mode" select="'block'"/>
				<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
				<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
				<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
				<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
				<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
				<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
				<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
				<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
				<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
				<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
			</xsl:call-template>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:style" mode="inline">
		<xsl:param name="node"/>
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>		
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="inline">
			<xsl:with-param name="node" select="$node"/>
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>			
		</xsl:apply-templates>
		<xsl:apply-templates select="w:rPr"/>
		<xsl:if test="$cell">
			<xsl:call-template name="apply.override.table.style">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="mode" select="'inline'"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
			</xsl:call-template>
		</xsl:if>			
	</xsl:template>
	
	<xsl:template match="w:style" mode="table">
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="table"/>
		<!-- TODO do we need any specific table style properties for the <dlg:table> element? -->
	</xsl:template>
	
	<xsl:template match="w:style" mode="rows">
		<xsl:param name="row"/>
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="rows">
			<xsl:with-param name="row" select="$row"/>
		</xsl:apply-templates>
		<!-- use the line height as the starting row height.  This is for table rows with no content -->
		<xsl:if test="w:pPr/w:spacing/@w:line">
			<xsl:attribute name="height">
				<xsl:call-template name="convert.resolution">
					<xsl:with-param name="res.from" select="w:pPr/w:spacing/@w:line"/>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>
		<xsl:apply-templates select="w:trPr"/>
		<xsl:if test="count($row/preceding-sibling::w:tr) = 0">
			<xsl:apply-templates select="w:tblStylePr[@w:type='firstRow']/w:trPr"/>
		</xsl:if>
		<xsl:if test="count($row/following-sibling::w:tr) = 0">
			<xsl:apply-templates select="w:tblStylePr[@w:type='lastRow']/w:trPr"/>
		</xsl:if>
	</xsl:template>

	<xsl:template match="w:style" mode="cells">
		<xsl:param name="cell"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="cells">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
		</xsl:apply-templates>
		<xsl:apply-templates select="w:tblPr/w:tblCellMar"/>
		<xsl:apply-templates select="w:tblPr/w:tblBorders/*">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="is.in.first.row" select="$num.prev.rows=0"/>
			<xsl:with-param name="is.in.last.row" select="$num.post.rows=0"/>
			<xsl:with-param name="is.in.first.col" select="$num.prev.cols=0"/>
			<xsl:with-param name="is.in.last.col" select="$num.post.cols=0"/>			
		</xsl:apply-templates>
		<xsl:apply-templates select="w:tcPr">
			<xsl:with-param name="cell" select="$cell"/>
		</xsl:apply-templates>	
		<xsl:call-template name="apply.override.table.style">
			<xsl:with-param name="cell" select="$cell"/>
			<xsl:with-param name="mode" select="'cell'"/>
			<xsl:with-param name="num.prev.rows" select="$num.prev.rows"/>
			<xsl:with-param name="num.post.rows" select="$num.post.rows"/>
			<xsl:with-param name="num.prev.cols" select="$num.prev.cols"/>
			<xsl:with-param name="num.post.cols" select="$num.post.cols"/>
			<xsl:with-param name="do.apply.first.row" select="$do.apply.first.row"/>
			<xsl:with-param name="do.apply.last.row" select="$do.apply.last.row"/>
			<xsl:with-param name="do.apply.first.col" select="$do.apply.first.col"/>
			<xsl:with-param name="do.apply.last.col" select="$do.apply.last.col"/>
			<xsl:with-param name="do.not.apply.row.banding" select="$do.not.apply.row.banding"/>
			<xsl:with-param name="do.not.apply.col.banding" select="$do.not.apply.col.banding"/>
		</xsl:call-template>		
	</xsl:template>
	
	<xsl:template match="w:style" mode="tabs">
		<xsl:param name="node"/>
		<xsl:apply-templates select="key('key.styles', w:basedOn/@w:val)" mode="tabs">
			<xsl:with-param name="node" select="$node"/>
		</xsl:apply-templates>
		<xsl:apply-templates select="w:pPr/w:tabs"/>		
	</xsl:template>
	
	<xsl:template name="apply.override.table.style">
		<xsl:param name="cell"/>
		<xsl:param name="mode"/>
		<xsl:param name="num.prev.rows"/>
		<xsl:param name="num.prev.cols"/>
		<xsl:param name="num.post.rows"/>
		<xsl:param name="num.post.cols"/>
		<xsl:param name="do.apply.first.row"/>
		<xsl:param name="do.apply.last.row"/>
		<xsl:param name="do.apply.first.col"/>
		<xsl:param name="do.apply.last.col"/>
		<xsl:param name="do.not.apply.row.banding"/>
		<xsl:param name="do.not.apply.col.banding"/>
		<xsl:if test="$cell">
			<xsl:variable name="is.header.row" select="boolean($cell/parent::w:tr/w:trPr/w:tblHeader)"/>
			<xsl:variable name="is.first.row" select="$num.prev.rows = 0"/>
			<xsl:variable name="is.last.row" select="$num.post.rows = 0 and not($is.first.row)"/>
			<xsl:variable name="is.even.row" select="$num.prev.rows mod 2 = 0 and not($is.first.row)"/>
			<xsl:variable name="is.odd.row" select="$num.prev.rows mod 2 = 1 and not($is.first.row)"/>
			<xsl:variable name="is.first.col" select="$num.prev.cols = 0"/>
			<xsl:variable name="is.last.col" select="$num.post.cols = 0 and not($is.first.col)"/>
			<xsl:variable name="is.even.col" select="$num.prev.cols mod 2 = 0 and not($is.first.col)"/>
			<xsl:variable name="is.odd.col" select="$num.prev.cols mod 2 = 1 and not($is.first.col)"/>
			<!-- banded columns first -->
			<xsl:if test="$is.odd.col and not($do.not.apply.col.banding)">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='band1Vert']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="orient" select="'v'"/>
				</xsl:call-template>
			</xsl:if> 
			<xsl:if test="$is.even.col and not($do.not.apply.col.banding)"> 
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='band2Vert']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="orient" select="'v'"/>
				</xsl:call-template>
			</xsl:if> 
			<!-- banded rows second -->
			<xsl:if test="$is.odd.row and not($do.not.apply.row.banding)">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='band1Horz']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="orient" select="'h'"/>
				</xsl:call-template>
			</xsl:if> 
			<xsl:if test="$is.even.row and not($do.not.apply.row.banding)">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='band2Horz']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
					<xsl:with-param name="orient" select="'h'"/>
				</xsl:call-template>
			</xsl:if> 
			<!-- first and last row -->
			<xsl:if test="$is.header.row or ($is.first.row and $do.apply.first.row)">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='firstRow']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="$is.last.row and $do.apply.last.row">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='lastRow']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<!-- first and last column -->
			<xsl:if test="$is.first.col and not($is.first.row) and $do.apply.first.col">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='firstCol']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>				
			<xsl:if test="$is.last.col and $do.apply.last.col">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='lastCol']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<!-- top left, top right, bottom left, bottom right -->
			<xsl:if test="$is.first.col and $is.first.row">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='nwCell']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="$is.last.col and $is.first.row">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='neCell']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="$is.first.col and $is.last.row">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='swCell']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
			<xsl:if test="$is.last.col and $is.last.row">
				<xsl:call-template name="apply.override.table.style.props">
					<xsl:with-param name="style" select="w:tblStylePr[@w:type='seCell']"/>
					<xsl:with-param name="mode" select="$mode"/>
					<xsl:with-param name="cell" select="$cell"/>
				</xsl:call-template>
			</xsl:if>
		</xsl:if>
	</xsl:template>
	
	<xsl:template name="apply.override.table.style.props">
		<xsl:param name="style"/>
		<xsl:param name="mode"/>
		<xsl:param name="cell"/>
		<xsl:param name="orient" select="''"/>
		<xsl:if test="$style">
			<xsl:choose>
				<xsl:when test="$mode = 'block'">
					<xsl:apply-templates select="$style/w:pPr">
						<xsl:with-param name="node" select="$cell"/>
					</xsl:apply-templates>
				</xsl:when>
				<xsl:when test="$mode = 'inline'">
					<xsl:apply-templates select="$style/w:rPr"/>
				</xsl:when>
				<xsl:when test="$mode = 'cell'">
					<xsl:apply-templates select="$style/w:tcPr">
						<xsl:with-param name="cell" select="$cell"/>
						<xsl:with-param name="orient" select="$orient"/>
					</xsl:apply-templates>
					<xsl:if test="$style/w:pPr/w:spacing/@w:line">
						<xsl:attribute name="height">
							<xsl:value-of select="$style/w:pPr/w:spacing/@w:line"/>
						</xsl:attribute>
					</xsl:if>
				</xsl:when>
			</xsl:choose>
		</xsl:if>
	</xsl:template>	
	
	<!-- ========= FORMATTING ========= -->
	<!--  <w:pgSz w:h="15840" w:w="12240"/> -->
	<xsl:template match="w:pgSz">
		<xsl:attribute name="height">
			<xsl:call-template name="convert.resolution">
				<xsl:with-param name="res.from" select="@w:h"/>
			</xsl:call-template>
		</xsl:attribute>
		<xsl:attribute name="width">			
			<xsl:call-template name="convert.resolution">
				<xsl:with-param name="res.from" select="@w:w"/>
			</xsl:call-template>
		</xsl:attribute>
	</xsl:template>
	
	<!-- <w:pgMar w:bottom="1440" w:footer="720" w:gutter="0" w:header="720" w:left="1440" w:right="1440" w:top="1440"/> -->
	<xsl:template match="w:pgMar">
    <xsl:param name="doc.part.rels"/>
    <xsl:if test="$doc.part.rels != ''">
      <xsl:attribute name="margin-bottom">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="@w:bottom"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="margin-left">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="@w:left"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="margin-right">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="@w:right"/>
        </xsl:call-template>
      </xsl:attribute>
      <xsl:attribute name="margin-top">
        <xsl:call-template name="convert.resolution">
          <xsl:with-param name="res.from" select="@w:top"/>
        </xsl:call-template>
      </xsl:attribute>
    </xsl:if>
	</xsl:template>
	
	<!-- <w:sz w:val="24"/> w:val is in double font -->
	<xsl:template match="w:sz|w:szCs">
    <xsl:param name="doc.defaults"/>
    <xsl:choose>
      <xsl:when test="self::w:szCs">
        <xsl:if test="$doc.defaults = 'true' and not(preceding-sibling::w:sz or following-sibling::w:sz)">
          <xsl:attribute name="font-size">
            <xsl:value-of select="concat(floor(@w:val div 2), '.00pt')"/>
          </xsl:attribute>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:attribute name="font-size">
          <xsl:value-of select="concat(floor(@w:val div 2), '.00pt')"/>
        </xsl:attribute>
      </xsl:otherwise>
    </xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:b">
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="font-weight">bold</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="font-weight">normal</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 
	</xsl:template>

	<xsl:template match="w:i">
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="font-style">italic</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="font-style">normal</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 
	</xsl:template>

	<xsl:template match="w:u">
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val = 'none'">
				<xsl:attribute name="text-decoration">none</xsl:attribute>
			</xsl:when>
			<xsl:when test="@w:val = 'single'">
				<xsl:attribute name="text-decoration">underline</xsl:attribute>
			</xsl:when>
			<xsl:when test="@w:val='words'">
				<xsl:message terminate="no">
					<xsl:text>Word-only underline is not a supported text formatting option.  Regular underline will be used</xsl:text>
				</xsl:message>
				<xsl:attribute name="text-decoration">underline</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message terminate="no">
					<xsl:text>Unsupported underline formatting found at: </xsl:text>
					<xsl:value-of select="@w:val"/>
					<xsl:text>. Single underline will be used</xsl:text>
				</xsl:message>
				<xsl:attribute name="text-decoration">underline</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Partially text formatting.  No Dialogue support -->
	<xsl:template match="w:strike">
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="text-decoration">line-through</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="text-decoration">none</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 	
	</xsl:template>
	
	<xsl:template match="w:dstrike">
		<xsl:message terminate="no">
			<xsl:text>Double strike-through is not a supported text formatting option.  Single strike-through will be used</xsl:text>
		</xsl:message>
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="text-decoration">line-through</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="text-decoration">none</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 	
	</xsl:template>
	
	<xsl:template match="w:caps">
		<xsl:message terminate="no">
			<xsl:text>All Caps is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="text-transform">uppercase</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="text-transform">none</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 	
	</xsl:template>
	
	<xsl:template match="w:smallCaps">
		<xsl:message terminate="no">
			<xsl:text>Small Caps is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
		<xsl:choose>
			<xsl:when test="not(@w:val) or @w:val='true' or @w:val='1'">
				<xsl:attribute name="font-variant">small-caps</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="font-variant">none</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose> 	
	</xsl:template>
	
	<xsl:template match="w:vertAlign">
		<xsl:attribute name="supersub"><xsl:value-of select="@w:val"/></xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:shd">
		<xsl:param name="cell" select="/.."/>
		<xsl:if test="not($cell)">
			<xsl:message terminate="no">
				<xsl:text>DXF does not support background colors on text</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="not(@w:fill = 'auto')">
			<xsl:attribute name="background-color">
				<xsl:call-template name="convert.hex.to.color">
					<xsl:with-param name="hex.color" select="@w:fill"/>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:highlight">
		<xsl:param name="cell" select="/.."/>
		<xsl:if test="not($cell)">
			<xsl:message terminate="no">
				<xsl:text>DXF does not support highlight colors on text</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="not(@w:val = 'auto')">
			<xsl:attribute name="background-color">
				<xsl:call-template name="convert.hex.to.color">
					<xsl:with-param name="hex.color" select="@w:val"/>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:position">        
		<xsl:attribute name="baseline-shift">          
			<xsl:value-of select="concat(@w:val div 2, '.00pt')"/>
		</xsl:attribute>      
	</xsl:template>

	<xsl:template match="w:pBdr">
		<xsl:apply-templates select="w:top|w:bottom|w:left|w:right" mode="warning_val"/>
    <xsl:if test="w:top and not(./w:top/@w:val = 'nil') and not(../../preceding-sibling::w:p[1]/w:pPr/w:pBdr/w:bottom)">
      <xsl:call-template name="apply.one.border">
        <xsl:with-param name="node" select="w:top"/>
        <xsl:with-param name="side" select="'top'"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="w:bottom and not(./w:bottom/@w:val = 'nil') and not(../../following-sibling::w:p[1]/w:pPr/w:pBdr/w:bottom)">
      <xsl:call-template name="apply.one.border">
        <xsl:with-param name="node" select="w:bottom"/>
        <xsl:with-param name="side" select="'bottom'"/>
      </xsl:call-template>
    </xsl:if>
    <xsl:if test="w:left and not(./w:left/@w:val = 'nil')">
      <xsl:message terminate="no">Left and right border lines are not supported</xsl:message>
    </xsl:if>
    <xsl:if test="w:right and not(./w:right/@w:val = 'nil')">
      <xsl:message terminate="no">Left and right border lines are not supported</xsl:message>
    </xsl:if>
	</xsl:template>

	<xsl:template match="w:top|w:bottom|w:left|w:right" mode="warning_val">
		<xsl:if test="@w:val and (@w:val != 'single')">
			<xsl:message terminate="no">Paragraph borders other than single lines are not supported</xsl:message>
		</xsl:if>
	</xsl:template>

	<xsl:template match="w:keepNext">
		<xsl:choose>
			<xsl:when test="@w:val='true' or @w:val='1'">
				<xsl:attribute name="keep-with-next">always</xsl:attribute>
			</xsl:when>
			<xsl:when test="@w:val='false' or @w:val='0'">
				<xsl:attribute name="keep-with-next">auto</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="keep-with-next">always</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="w:spacing">
		<xsl:param name="node"/>
		<xsl:choose>
			<xsl:when test="@w:val">
				<xsl:attribute name="letter-spacing">
					<xsl:value-of select="concat(@w:val div 20, 'pt')"/>
				</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:if test="boolean(@w:before)">
					<xsl:attribute name="space-before">
						<xsl:call-template name="convert.resolution">
							<xsl:with-param name="res.from" select="@w:before"/>
						</xsl:call-template>
					</xsl:attribute>
				</xsl:if>
        <xsl:if test="boolean(@w:after)">
          <xsl:attribute name="space-after">
            <xsl:choose>
              <xsl:when test="boolean(@w:after)">
                <xsl:call-template name="convert.resolution">
                  <xsl:with-param name="res.from" select="@w:after"/>
                </xsl:call-template>
              </xsl:when>
              <!-- Prevent excess padding between, for example, table of contents items. -->
              <xsl:otherwise>0lu</xsl:otherwise>
            </xsl:choose>
          </xsl:attribute>
        </xsl:if>
				
				<xsl:attribute name="line-height">0lu</xsl:attribute>
				<xsl:choose>
					<xsl:when test="@w:lineRule = 'auto'">
            <xsl:choose>
              <xsl:when test="$mustFlow = 'true'">
                <xsl:attribute name="line-spacing">multiple</xsl:attribute>
                <xsl:variable name="res.to" select="@w:line div 240"/>
                <xsl:attribute name="line-height">
                  <xsl:value-of select="@w:line div 240 * 10"/>
                </xsl:attribute>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="line-spacing">at-least</xsl:attribute>
                <xsl:call-template name="apply.line.height">
                  <xsl:with-param name="node" select="$node"/>
                  <xsl:with-param name="height" select="@w:line"/>
                </xsl:call-template>
              </xsl:otherwise>
            </xsl:choose>
					</xsl:when>
					<xsl:when test="@w:lineRule = 'atLeast'">
						<xsl:attribute name="line-spacing">at-least</xsl:attribute>
						<xsl:call-template name="apply.line.height">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="height" select="@w:line"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:when test="@w:lineRule = 'exactly'">
						<xsl:attribute name="line-spacing">exact</xsl:attribute>
						<xsl:call-template name="apply.line.height">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="height" select="@w:line"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="apply.line.height">
							<xsl:with-param name="node" select="$node"/>
							<xsl:with-param name="height" select="@w:line"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:framePr">
		<xsl:if test="@w:dropCap">	
			<xsl:message terminate="no">
				<xsl:text>Drop Cap is not a supported formatting option</xsl:text>
			</xsl:message>
		</xsl:if>
    <xsl:message terminate="no">
      <xsl:text>Text frame is not a supported option and may cause unexpected results</xsl:text>
    </xsl:message>
	</xsl:template>
	
	<!-- Unsupported text formatting.  No XSL-FO or Dialogue support -->
	<xsl:template match="w:shadow">
		<xsl:message terminate="no">
			<xsl:text>Shadow is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="w:outline">
		<xsl:message terminate="no">
			<xsl:text>Outline is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template match="w:emboss">
		<xsl:message terminate="no">
			<xsl:text>Emboss is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template match="w:imprint">
		<xsl:message terminate="no">
			<xsl:text>Imprint is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="w:kern">
		<xsl:message terminate="no">
			<xsl:text>Kerning is not a supported text formatting option and will be ignored</xsl:text>
		</xsl:message>
	</xsl:template>
	<!-- End unsupported text formatting -->	
	
	<xsl:template name="apply.line.height">
		<xsl:param name="node"/>
		<xsl:param name="height"/>
		<xsl:variable name="line.has.embed" select="$node and ($node/child::w:r/w:drawing/wp:inline or $node/child::w:r/w:pict)"/>
		<xsl:attribute name="line-height">
			<xsl:choose>
				<xsl:when test="$line.has.embed or not(@w:line) or (boolean($node) and $node/ancestor-or-self::w:tc)">0lu</xsl:when>
				<xsl:otherwise>
					<xsl:call-template name="convert.resolution">
						<xsl:with-param name="res.from" select="@w:line"/>
					</xsl:call-template>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:rFonts">
		<xsl:if test="@w:ascii or @w:cs or @w:asciiTheme or @w:cstheme or @w:eastAsiaTheme">
			<xsl:attribute name="font-family">
				<xsl:choose>
					<xsl:when test="@w:ascii">
						<xsl:value-of select="@w:ascii"/>
					</xsl:when>
					<xsl:when test="@w:asciiTheme='majorHAnsi' or @w:cstheme='majorHAnsi' or @w:eastAsiaTheme='majorEastAsia'">
						<xsl:value-of select="$majorFont"/>
					</xsl:when>
					<xsl:when test="@w:asciiTheme='minorHAnsi' or @w:cstheme='minorHAnsi' or @w:eastAsiaTheme='minorEastAsia'">
						<xsl:value-of select="$minorFont"/>
					</xsl:when>			
					<xsl:when test="@w:cs">
						<xsl:value-of select="@w:cs"/>
					</xsl:when>
					<xsl:otherwise/>
				</xsl:choose>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template name="get.tinted.or.shaded.hex.theme.color">
		<xsl:param name="theme.color"/>
		<xsl:param name="tint.hex"/>
		<xsl:param name="shade.hex"/>
		
		<xsl:choose>
			<xsl:when test="boolean($tint.hex) and $tint.hex != ''">
				<xsl:call-template name="convert.hex.to.tinted.hex">
					<xsl:with-param name="color.theme.hex" select="$theme.color"/>
					<xsl:with-param name="color.theme.tint.hex" select="$tint.hex"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:when test="boolean($shade.hex) and $shade.hex != ''">
				<xsl:call-template name="convert.hex.to.shaded.hex">
					<xsl:with-param name="color.theme.hex" select="$theme.color"/>
					<xsl:with-param name="color.theme.shade.hex" select="$shade.hex"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$theme.color"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Pass in a w:color node, get a rgb() value with the theme applied as necessary. -->
	<xsl:template name="get.rgb.color.from.wcolor">
		<xsl:param name="wcolor"/>
		
		<xsl:variable name="color.hex">
			<xsl:choose>
				<xsl:when test="$wcolor/@w:themeColor">
					<xsl:variable name="theme_color">
						<xsl:choose>
							<xsl:when test="boolean(key('key.theme.colors', $wcolor/@w:themeColor))">
								<xsl:value-of select="key('key.theme.colors', $wcolor/@w:themeColor)/a:srgbClr/@val"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$wcolor/@w:val"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:call-template name="get.tinted.or.shaded.hex.theme.color">
						<xsl:with-param name="theme.color" select="$theme_color"/>
						<xsl:with-param name="shade.hex" select="$wcolor/@w:themeShade"/>
						<xsl:with-param name="tint.hex" select="$wcolor/@w:themeTint"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$wcolor/@w:val"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:call-template name="convert.hex.to.color">
			<xsl:with-param name="hex.color" select="$color.hex"/>
		</xsl:call-template>
	</xsl:template>
	
	<xsl:template match="w:color">
		<xsl:if test="not(ancestor::*[2][self::w:pPr])">
			<xsl:attribute name="color">
				<xsl:call-template name="get.rgb.color.from.wcolor">
					<xsl:with-param name="wcolor" select="self::node()"/>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:jc">
		<xsl:attribute name="text-align">	
			<xsl:choose>
				<xsl:when test="@w:val='left'">left</xsl:when>
				<xsl:when test="@w:val='right'">right</xsl:when>
				<xsl:when test="@w:val='center'">center</xsl:when>
				<xsl:when test="@w:val='both' or @w:val='distribute'">
					<xsl:text>justify</xsl:text>
				</xsl:when>
				<xsl:otherwise><xsl:text>inherit</xsl:text></xsl:otherwise>
			</xsl:choose>	
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="w:start">
		<xsl:variable name="numFmt" select="ancestor::*/w:numFmt"/>
		<xsl:if test="boolean(@w:val) and (not(boolean($numFmt)) or $numFmt/@w:val != 'bullet')">
			<xsl:attribute name="number-value">
				<xsl:value-of select="@w:val"/>
			</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:contextualSpacing">
		<xsl:param name="node"/>
    <xsl:choose>
      <xsl:when test="not($node)">
        <!-- We need to account for cndition when we may have an empty node CR-63489 -->
        <xsl:apply-templates select=".">
          <xsl:with-param name="node" select="ancestor::w:p"/>
        </xsl:apply-templates>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="next_node" select="$node/following-sibling::w:p[1]"/>
        <xsl:variable name="node_style_id" select="$node/w:pPr/w:pStyle/@w:val"/>
        <xsl:variable name="next_node_style_id" select="$next_node/w:pPr/w:pStyle/@w:val"/>
        <xsl:variable name="node_style" select="$styles/w:style[@w:styleId=$node_style_id]"/>
        <xsl:variable name="next_node_style" select="$styles/w:style[@w:styleId=$next_node_style_id]"/>
        <xsl:variable name="style_defined" select="boolean($node_style)"/>
        <xsl:variable name="next_style_defined" select="boolean($next_node_style)"/>
        <xsl:variable name="diff_styles" select="$node_style_id != $next_node_style_id"/>
        <xsl:variable name="is_last_node" select="not(boolean($next_node))"/>

        <xsl:variable name="specific_spacing" select="ancestor::w:pPr/w:spacing"/>
        <xsl:variable name="default_spacing" select="ancestor::w:pPr/ancestor::w:style/ancestor::w:styles/w:docDefaults/w:pPrDefault/w:pPr/w:spacing"/>
        <xsl:variable name="spacing">
          <xsl:choose>
            <xsl:when test="boolean($specific_spacing)">
              <xsl:value-of select="$specific_spacing/@w:after"/>
            </xsl:when>
            <xsl:when test="boolean($default_spacing)">
              <xsl:value-of select="$default_spacing/@w:after"/>
            </xsl:when>
          </xsl:choose>
        </xsl:variable>

        <xsl:variable name="space_after">
          <xsl:choose>
            <xsl:when test="$style_defined and (not($next_style_defined) or $diff_styles) and not($is_last_node)">
              <xsl:call-template name="convert.resolution">
                <xsl:with-param name="res.from" select="$spacing"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:when test="$next_style_defined and (not($style_defined) or $diff_styles) and not($is_last_node)">
              <xsl:call-template name="convert.resolution">
                <xsl:with-param name="res.from" select="$spacing"/>
              </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
              <xsl:value-of select="'0lu'"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>

        <xsl:if test="$space_after != 'NaNlu'">
          <xsl:attribute name="space-after">
            <xsl:value-of select="$space_after"/>
          </xsl:attribute>
        </xsl:if>

        <xsl:attribute name="space-before">0lu</xsl:attribute>

      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
	
	<!-- ======== TOCs ========= -->
	<xsl:template match="w:sdt">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="is.header.footer"/>
    <xsl:apply-templates select="*">
      <xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
      <xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
      <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
      <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      <xsl:with-param name="topMargin" select="$topMargin"/>
      <xsl:with-param name="leftMargin" select="$leftMargin"/>
      <xsl:with-param name="rightMargin" select="$rightMargin"/>
      <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
      <xsl:with-param name="pageHeight" select="$pageHeight"/>
      <xsl:with-param name="pageWidth" select="$pageWidth"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:sdtPr">
		<xsl:apply-templates select="*[not(self::w:rPr)]"/>
	</xsl:template>

	<xsl:template match="w:docPartObj">
		<xsl:apply-templates select="*"/>
	</xsl:template>

	<xsl:template match="w:docPartGallery">
		<xsl:if test="@w:val='Table of Contents'">
			<dlg:table-of-contents>
				<xsl:call-template name="apply.table-of-contents.defaults"/>
			</dlg:table-of-contents>
		</xsl:if>
	</xsl:template>

	<xsl:template name="apply.table-of-contents.defaults">
		<xsl:call-template name="apply.default.dlg.object.props"/>
		<xsl:attribute name="can-split">false</xsl:attribute>
		<xsl:attribute name="ignore-relative">no</xsl:attribute>
		<xsl:attribute name="min-height">0</xsl:attribute>
		<xsl:attribute name="pos-rel-to-above">0</xsl:attribute>
		<xsl:attribute name="column-width">500</xsl:attribute>
		<xsl:attribute name="design-var-ndx">0</xsl:attribute>
		<xsl:attribute name="entry-wrap">true</xsl:attribute>
		<xsl:attribute name="justification">right</xsl:attribute>
		<xsl:attribute name="leader">.</xsl:attribute>
		<xsl:attribute name="level-indent">250</xsl:attribute>
		<xsl:attribute name="num-levels">4</xsl:attribute>
		<xsl:attribute name="page-number-position">right-column</xsl:attribute>
		<xsl:attribute name="toc-hyperlink">false</xsl:attribute>
		<xsl:attribute name="toc-type">complete</xsl:attribute>
	</xsl:template>

	<xsl:template match="w:sdtEndPr">
		<xsl:apply-templates select="*[not(self::w:rPr)]"/>
	</xsl:template>
	
	<xsl:template match="w:sdtContent">
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="is.header.footer"/>
    <xsl:apply-templates select="*">
      <xsl:with-param name="parent.has.sectPr" select="boolean(w:p/w:pPr/w:sectPr)"/>
      <xsl:with-param name="body.end.indent" select="w:sectPr/w:pgMar/@w:right"/>
      <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
      <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      <xsl:with-param name="topMargin" select="$topMargin"/>
      <xsl:with-param name="leftMargin" select="$leftMargin"/>
      <xsl:with-param name="rightMargin" select="$rightMargin"/>
      <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
      <xsl:with-param name="pageHeight" select="$pageHeight"/>
      <xsl:with-param name="pageWidth" select="$pageWidth"/>
    </xsl:apply-templates>
	</xsl:template>

	<xsl:template name="apply.table-of-contents-entry.defaults">
		<xsl:attribute name="source">static</xsl:attribute>
	</xsl:template>

	<xsl:template match="w:hyperlink">
		<xsl:message terminate="no">
			<xsl:text>DXF does not support hyperlinks.  The text will appear but no link will be created</xsl:text>
		</xsl:message>
		<xsl:apply-templates select="*"/>
	</xsl:template>

	<!-- ======== BULLETS & NUMBERING ========= -->
	<xsl:template match="w:lvl">
		<xsl:param name="next_lvl"/>
		<xsl:param name="next_next_lvl"/>
		<xsl:param name="abstract_num_id"/>
		<xsl:param name="num_id"/>
		<xsl:apply-templates select="*">
			<xsl:with-param name="next_lvl" select="$next_lvl"/>
			<xsl:with-param name="next_next_lvl" select="$next_next_lvl"/>
			<xsl:with-param name="abstract_num_id" select="$abstract_num_id"/>
			<xsl:with-param name="num_id" select="$num_id"/>
		</xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:numFmt">
		<xsl:param name="abstract_num_id"/>
		<xsl:param name="num_id"/>
		
		<xsl:variable name="list_type">
			<xsl:call-template name="numFmt2list-type">
				<xsl:with-param name="numFmt" select="@w:val"/>
				<xsl:with-param name="abstract_num_id" select="$abstract_num_id"/>
				<xsl:with-param name="num_id" select="$num_id"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- If this is a list item, we need a smaller default tab stop so that the
			 list is slightly indented from the left (as opposed to flush with the
			 left margin), as it appears in Word.  Redefine the default tab here
			 since we know we're working with a list. -->
		<!--<xsl:if test="$list_type != 'none'">
			<xsl:attribute name="default-tab">
				<xsl:call-template name="try.sum.lu">
					<xsl:with-param name="init_value" select="$default_tab_stop"/>
					<xsl:with-param name="amount">-250lu</xsl:with-param>
				</xsl:call-template>
			</xsl:attribute>
		</xsl:if>-->
		
		<!-- DXF: none | bullet | number -->
		<xsl:attribute name="list-type">
			<xsl:value-of select="$list_type"/>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template name="simplify.lvl">
		<xsl:param name="numFmt"/>
		<xsl:param name="lvlText"/>
		
		<xsl:variable name="number-type">
			<xsl:call-template name="numFmtAndLvlText2number-type">
				<xsl:with-param name="numFmt" select="$numFmt"/>
				<xsl:with-param name="lvlText" select="$lvlText"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- When working with a numbered list (so when DXF number-type is not
			 'bullet'), change formats like 'Article %1.' to '%1.' since we don't
			 support the custom-text bullet points. -->
		<xsl:choose>
			<xsl:when test="$number-type = 'bullet'">
				<xsl:value-of select="$lvlText"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:call-template name="strip-tokens-without-key">
					<xsl:with-param name="key" select="'%'"/>
					<xsl:with-param name="separator" select="' '"/>
					<xsl:with-param name="text" select="$lvlText"/>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template match="w:lvlText"><!-- e.g., %1.%2.%3 or %1 -->
		<xsl:param name="next_lvl"/>
		<xsl:param name="next_next_lvl"/>
		
		<xsl:variable name="lvl_id" select="ancestor::w:lvl/@w:ilvl"/>
		<xsl:variable name="numFmt" select="ancestor::w:lvl/w:numFmt/@w:val"/>
		
		<xsl:variable name="number-type">
			<xsl:call-template name="numFmtAndLvlText2number-type">
				<xsl:with-param name="numFmt" select="$numFmt"/>
				<xsl:with-param name="lvlText" select="@w:val"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- If a deeper item comes before a higher-level item, Word starts the higher
			 item at the second number; Designer starts them at the first number.  E.g.,
			 current level is 1, next level is 3, level after that is 2.  Want to warn
			 the user in such a case. -->
		<xsl:if test="$lvl_id and $next_lvl and $next_next_lvl">
			<xsl:variable name="next_lvl_id" select="$next_lvl/@w:ilvl"/>
			<xsl:variable name="next_next_lvl_id" select="$next_next_lvl/@w:ilvl"/>
			<xsl:variable name="next-number-type">
				<xsl:call-template name="numFmtAndLvlText2number-type">
					<xsl:with-param name="numFmt" select="$next_lvl/w:numFmt/@w:val"/>
					<xsl:with-param name="lvlText" select="$next_lvl/w:lvlText/@w:val"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="next-next-number-type">
				<xsl:call-template name="numFmtAndLvlText2number-type">
					<xsl:with-param name="numFmt" select="$next_next_lvl/w:numFmt/@w:val"/>
					<xsl:with-param name="lvlText" select="$next_next_lvl/w:lvlText/@w:val"/>
				</xsl:call-template>
			</xsl:variable>
			<xsl:variable name="are_numeric_items" select="$number-type != 'bullet' and $next-number-type != 'bullet' and $next-next-number-type != 'bullet'"/>
			
			<!-- Ex:
				 1) value
							a. value
						i. value-->
			<xsl:variable name="lvl_order_132" select="$next_next_lvl_id &gt; $lvl_id and $next_lvl_id &gt; $next_next_lvl_id and $next_lvl_id &gt; $lvl_id"/>
			
			<!-- Problem with detecting this nesting is that 'normal' lists have this ordering,
				 except their numbers aren't the first numbers at that level.  For now, do not warn.
				 Ex:
							 1) value
						 a. value
					i. value -->
			<!--<xsl:variable name="lvl_order_321" select="$next_lvl_id &lt; $lvl_id and $next_next_lvl_id &lt; $next_lvl_id"/>-->
			<xsl:if test="$are_numeric_items and $lvl_order_132">
				<xsl:message terminate="no">
					<xsl:text>Numbering will start at one for numbered list item at depth </xsl:text>
					<xsl:value-of select="$next_next_lvl_id"/>
					<xsl:text> since it follows list item at depth </xsl:text>
					<xsl:value-of select="$next_lvl_id"/>
				</xsl:message>
			</xsl:if>
		</xsl:if>
	
		<!-- When working with a numbered list (so when DXF number-type is not
			 'bullet'), change formats like 'Article %1.' to '%1.' since we don't
			 support the custom-text bullet points. -->
		<xsl:variable name="lvlText_simplified">
			<xsl:call-template name="simplify.lvl">
				<xsl:with-param name="lvlText" select="@w:val"/>
				<xsl:with-param name="numFmt" select="$numFmt"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:if test="@w:val != $lvlText_simplified">
			<xsl:message terminate="no">
				<xsl:text>Simplifying docx number format for bullet from '</xsl:text>
				<xsl:value-of select="@w:val"/>
				<xsl:text>' to '</xsl:text>
				<xsl:value-of select="$lvlText_simplified"/>
				<xsl:text>'</xsl:text>
			</xsl:message>
		</xsl:if>
		
		<!-- Designer doesn't support numbered lists without punctuation, warn user: -->
		<xsl:variable name="lvlText_last_char" select="number(substring($lvlText_simplified, string-length($lvlText_simplified)))"/>
		<xsl:if test="($lvlText_last_char &lt;= 0 or $lvlText_last_char &gt; 0) and $number-type != 'bullet'">
			<xsl:message terminate="no">
				<xsl:text>Changing docx number format for bullet from a number without punctuation to a number with a period</xsl:text>
			</xsl:message>
		</xsl:if>
		
		<xsl:attribute name="number-string">
			<xsl:value-of select="$lvlText_simplified"/>
		</xsl:attribute>
		
		<!-- Ex.: %1 = 1 number format token, %1.%2 = 2 number format tokens, etc. -->
		<xsl:variable name="lvlText_token_count">
			<xsl:call-template name="non-empty.token.count">
				<xsl:with-param name="text">
					<xsl:call-template name="strip-outer-parentheses">
						<xsl:with-param name="text" select="$lvlText_simplified"/>
					</xsl:call-template>
				</xsl:with-param>
				<xsl:with-param name="separator" select="'%'"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:if test="$lvlText_token_count &gt; 1">
			<xsl:message terminate="no">
				<xsl:text>Indentation for hierarchical numbered lists may differ in DXF from Word</xsl:text>
			</xsl:message>
			<xsl:attribute name="hierarchical">true</xsl:attribute>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="w:lvlJc">
	</xsl:template>
	
	<!-- ========= DRAWING ITEMS & IMAGES ========== -->
	<xsl:template match="w:drawing">
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:param name="is.header.footer"/>
    <xsl:apply-templates select="*">
      <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
      <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
      <xsl:with-param name="topMargin" select="$topMargin"/>
      <xsl:with-param name="leftMargin" select="$leftMargin"/>
      <xsl:with-param name="rightMargin" select="$rightMargin"/>
      <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
      <xsl:with-param name="pageHeight" select="$pageHeight"/>
      <xsl:with-param name="pageWidth" select="$pageWidth"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="w:object">
		<xsl:message>
			<xsl:text>Embedded object of type </xsl:text>
			<xsl:value-of select="o:OLEObject/@ProgID"/>
			<xsl:text> is not supported.  Embedded object ignored</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template match="wp:inline">
    <xsl:param name="doc.part.rels"/>
    <dlg:embedded-object>
      <xsl:call-template name="apply.embedded.inline.props"/>
      <xsl:apply-templates select="*">
        <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
      </xsl:apply-templates>
		</dlg:embedded-object>
	</xsl:template>
	
	<xsl:template match="wp:anchor">
    <xsl:param name="doc.part.rels"/>
    <xsl:param name="is.header.footer"/>
    <xsl:param name="topMargin"/>
    <xsl:param name="leftMargin"/>
    <xsl:param name="rightMargin"/>
    <xsl:param name="bottomMargin"/>
    <xsl:param name="pageHeight"/>
    <xsl:param name="pageWidth"/>
    <xsl:choose>
      <xsl:when test="$mustFlow = 'true'">
        <dlg:embedded-object>
          <xsl:call-template name="apply.embedded.anchor.props">
            <xsl:with-param name="topMargin" select="$topMargin"/>
            <xsl:with-param name="leftMargin" select="$leftMargin"/>
            <xsl:with-param name="rightMargin" select="$rightMargin"/>
            <xsl:with-param name="bottomMargin" select="$bottomMargin"/>
            <xsl:with-param name="pageHeight" select="$pageHeight"/>
            <xsl:with-param name="pageWidth" select="$pageWidth"/>
            <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
          </xsl:call-template>
          <xsl:apply-templates select="*">
            <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
            <xsl:with-param name="is.header.footer" select="$is.header.footer"/>
          </xsl:apply-templates>
        </dlg:embedded-object>
        <xsl:choose>
          <xsl:when test="wp:wrapNone">
            <xsl:if test="@behindDoc = '0' or @behindDoc = 'false'">
              <xsl:message terminate="no">
                <xsl:text>An image that is placed in front of text was encountered. OpenText Exstream does not support images that are placed in front of text for DOCX import. OpenText Exstream will placed these images behind the text.</xsl:text>
              </xsl:message>
            </xsl:if>
          </xsl:when>
          <xsl:otherwise>
            <xsl:message terminate="no">
              <xsl:text>DOCX import has encountered a wrapping option that is not supported for images. OpenText Exstream will placed these images behind the text.</xsl:text>
            </xsl:message>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message terminate="no">
          <xsl:text>"In Line with Text" is the only Text Wrapping option supported for embedded objects.  Embedded object ignored</xsl:text>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
	</xsl:template>
	
	<xsl:template match="wp:extent">
		<xsl:attribute name="height">
			<xsl:value-of select="@cy div 914.4"/>
		</xsl:attribute>	
		<xsl:attribute name="width">
			<xsl:value-of select="@cx div 914.4"/>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="wp:effectExtent">
	</xsl:template>
	
	<xsl:template match="wp:docPr">
	</xsl:template>
	
	<xsl:template match="wp:cNvGraphicFramePr">
	</xsl:template>

  <xsl:template match="wp:positionH">
  </xsl:template>

  <xsl:template match="wp:positionV">
  </xsl:template>

  <xsl:template match="wp:wrapNone">
  </xsl:template>

  <xsl:template match="a:graphic">
    <xsl:param name="doc.part.rels"/>
    <xsl:apply-templates select="*">
      <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="a:graphicData">
    <xsl:param name="doc.part.rels"/>
    <xsl:apply-templates select="*">
      <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
    </xsl:apply-templates>
	</xsl:template>
	
	<xsl:template match="pic:pic">
    <xsl:param name="doc.part.rels"/>
    <dlg:image>
			<xsl:call-template name="apply.image.props"/>
      <xsl:apply-templates select="*[not(self::pic:nvPicPr or self::pic:spPr)]">
        <xsl:with-param name="doc.part.rels" select="$doc.part.rels"/>
      </xsl:apply-templates>
		</dlg:image>
	</xsl:template>

	<xsl:template match="pic:nvPicPr">
		<xsl:attribute name="reference-name"><xsl:value-of select="pic:cNvPr/@name"/></xsl:attribute>
	</xsl:template>
	
	<xsl:template match="pic:spPr">
		<xsl:apply-templates select="a:ln"/>
		<xsl:apply-templates select="a:scene3d"/>
		<xsl:apply-templates select="a:effectLst"/>
	</xsl:template>
	
	<xsl:template match="a:ln">
		<xsl:if test="not(boolean(a:noFill))">
			<xsl:attribute name="pen">true</xsl:attribute>
			<xsl:attribute name="pen-width">
				<xsl:value-of select="concat(@w div 914.4, 'lu')"/>
			</xsl:attribute>
			<xsl:apply-templates select="a:prstDash"/>
			<xsl:if test="not(a:prstDash)">
				<xsl:attribute name="pen-style">solid</xsl:attribute>
			</xsl:if>
			<xsl:apply-templates select="a:solidFill"/>
		</xsl:if>
		<xsl:if test="@cmpd">
			<xsl:message terminate="no">
				<xsl:text>Compound borders are not supported.  A solid fill will be used</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="@cap">
			<xsl:message terminate="no">
				<xsl:text>Border caps are not supported</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="a:gradFill">
			<xsl:message terminate="no">
				<xsl:text>Gradient borders are not supported.  Neither color will be used</xsl:text>
			</xsl:message>		
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:prstDash">
		<xsl:choose>
			<xsl:when test="@val = 'solid'">
				<xsl:attribute name="pen-style">solid</xsl:attribute>
			</xsl:when>
			<xsl:when test="@val = 'sysDot'">
				<xsl:attribute name="pen-style">shortdashed</xsl:attribute>
			</xsl:when>
			<xsl:when test="@val = 'sysDash' or @val = 'dash' or @val = 'lgDash'">
				<xsl:attribute name="pen-style">dashed</xsl:attribute>
			</xsl:when>
			<xsl:when test="@val = 'dashDot' or @val = 'lgDashDot'">
				<xsl:attribute name="pen-style">dotted</xsl:attribute>
			</xsl:when>
			<xsl:when test="@val = 'lgDashDotDot'">
				<xsl:attribute name="pen-style">fardashed</xsl:attribute>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="pen-style">solid</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="a:solidFill">
		<xsl:apply-templates select="a:srgbClr">
			<xsl:with-param name="prefix" select="'pen'"/>
		</xsl:apply-templates>
		<xsl:apply-templates select="*[not(self::a:srgbClr)]"/>
	</xsl:template>
	
	<xsl:template match="a:gradFill">
		<xsl:message terminate="no">
			<xsl:text>Gradient borders are not supported.  Neither will be used</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template match="a:srgbClr">
		<xsl:param name="prefix"/>
		<xsl:attribute name="{$prefix}-color">
			<xsl:call-template name="convert.hex.to.color">
				<xsl:with-param name="hex.color" select="@val"/>
			</xsl:call-template>
		</xsl:attribute>
		<xsl:apply-templates select="*"/>
	</xsl:template>
	
	<xsl:template match="a:alpha">
		<xsl:message terminate="no">
			<xsl:text>Transparency on borders is not supported.  Full color will be used</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="a:bevel">
		<xsl:message terminate="no">
			<xsl:text>Border bevel join type not supported</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="a:round">
		<xsl:message terminate="no">
			<xsl:text>Border round join type not supported</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template match="a:miter">
		<xsl:message terminate="no">
			<xsl:text>Border miter join type not supported</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="a:effectLst">
		<xsl:apply-templates select="*"/>
	</xsl:template>

	<xsl:template match="a:outerShdw">
		<xsl:attribute name="shadow">lr</xsl:attribute>
		<xsl:apply-templates select="a:srgbClr">
			<xsl:with-param name="prefix" select="'shadow'"/>
		</xsl:apply-templates>
		<xsl:apply-templates select="*[not(self::a:srgbClr)]"/>
	</xsl:template>
	
	<xsl:template match="a:schemeClr">
		<xsl:attribute name="pen-color">
			<xsl:variable name="accent" select="@val"/>
			<xsl:call-template name="convert.hex.to.color">
				<xsl:with-param name="hex.color" select="$theme/a:themeElements/a:clrScheme/*[local-name() = $accent]/a:srgbClr/@val"/>
			</xsl:call-template>
		</xsl:attribute>
	</xsl:template>
	
	<xsl:template match="pic:blipFill">
    <xsl:param name="doc.part.rels"/>
		<xsl:choose>
      <xsl:when test="$doc.part.rels = ''">
        <xsl:variable name="image.part.name" select="concat('/word/', key('key.doc.rels', a:blip/@r:embed)/@Target)"/>
        <xsl:call-template name="create.image">
          <xsl:with-param name="image.part" select="/pkg:package/pkg:part[@pkg:name=$image.part.name]"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="rel.id" select="a:blip/@r:embed"/>
        <xsl:variable name="image.part.name">
          <xsl:apply-templates mode="get.part.rel.name" select="/pkg:package/pkg:part[@pkg:name=$doc.part.rels]/pkg:xmlData/rels:Relationships/rels:Relationship[@Id = $rel.id]"/>
        </xsl:variable>
        <xsl:call-template name="create.image">
          <xsl:with-param name="image.part" select="/pkg:package/pkg:part[@pkg:name=$image.part.name]"/>
        </xsl:call-template>-->
      </xsl:otherwise>
    </xsl:choose>

		<xsl:apply-templates select="a:srcRect|a:blip|a:stretch"/>
	</xsl:template>

  <xsl:template mode="get.part.rel.name" match="rels:Relationship">
    <xsl:text>/word/</xsl:text>
    <xsl:value-of select="./@Target"/>
  </xsl:template>

  <xsl:template name="create.image">
    <xsl:param name="image.part"/>
    <xsl:choose>
      <xsl:when test="$image.part/@pkg:contentType = 'image/jpeg'">
        <xsl:variable name="image.data" select="$image.part/pkg:binaryData"/>
        <xsl:if test="$image.data">
          <dlg:bitmap>
            <dlg:binary>
              <xsl:attribute name="encoding">base64</xsl:attribute>
              <xsl:value-of select="string($image.data)"/>
            </dlg:binary>
          </dlg:bitmap>
        </xsl:if>
      </xsl:when>
      <xsl:otherwise>
        <xsl:message terminate="no">
          <xsl:text>Image of type </xsl:text>
          <xsl:value-of select="$image.part/@pkg:contentType"/>
          <xsl:text> found.  DXF only supports JPEG images</xsl:text>
        </xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>
	
	<xsl:template match="a:srcRect">
		<xsl:message terminate="no">
			<xsl:text>Image cropping not supported</xsl:text>
		</xsl:message>
	</xsl:template>
	
	<xsl:template match="a:blip">
		<xsl:apply-templates select="*"/>
	</xsl:template>
	
	<xsl:template match="a:lum">
		<xsl:if test="@contrast">
			<xsl:message terminate="no">
				<xsl:text>Image contrast adjustments not supported</xsl:text>
			</xsl:message>
		</xsl:if>
		<xsl:if test="@bright">
			<xsl:message terminate="no">
				<xsl:text>Image brightness adjustments not supported</xsl:text>
			</xsl:message>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="a:biLevel|a:duotone|a:grayscl">
		<xsl:message terminate="no">
			<xsl:text>Image recoloring not supported</xsl:text>
		</xsl:message>
	</xsl:template>	
	
	<xsl:template match="a:scene3d">
		<xsl:message terminate="no">
			<xsl:text>3-D formatting options are not supported</xsl:text>
		</xsl:message>
	</xsl:template>

	<xsl:template name="apply.image.props">
		<xsl:call-template name="apply.default.dlg.object.props"/>
    <xsl:attribute name="stretch-to-frame">true</xsl:attribute>
		<xsl:apply-templates select="pic:nvPicPr"/>
		<xsl:apply-templates select="pic:spPr"/>
		<xsl:call-template name="apply.image.embed.rect"/> 
	</xsl:template>
	
	<xsl:template name="apply.image.embed.rect">
		<dlg:rect>
			<xsl:attribute name="top">0lu</xsl:attribute>
			<xsl:attribute name="bottom">
				<xsl:choose>
					<xsl:when test="boolean(pic:spPr/a:xfrm/a:ext/@cy)">
						<xsl:value-of select="concat(pic:spPr/a:xfrm/a:ext/@cy div 914.4, 'lu')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat(ancestor::wp:inline[1]/wp:extent/@cy div 914.4, 'lu')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
			<xsl:attribute name="left">0lu</xsl:attribute>
			<xsl:attribute name="right">
				<xsl:choose>
					<xsl:when test="boolean(pic:spPr/a:xfrm/a:ext/@cx)">
						<xsl:value-of select="concat(pic:spPr/a:xfrm/a:ext/@cx div 914.4, 'lu')"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat(ancestor::wp:inline[1]/wp:extent/@cx div 914.4, 'lu')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</dlg:rect>	
	</xsl:template>
	
	<xsl:template match="w:pict">
		<xsl:apply-templates select="*"/>
	</xsl:template>
	
	<xsl:template match="v:shapetype">
		<xsl:message terminate="no">Shape templates are not supported</xsl:message>
	</xsl:template>
	
	<xsl:template match="v:rect">
		<xsl:call-template name="add.embedded.textbox"/>
	</xsl:template>
	
	<xsl:template match="v:shape">
		<xsl:variable name="shapetype.id" select="substring-after(@type, '#')"/>
		<xsl:call-template name="add.embedded.textbox">
			<xsl:with-param name="shape.type" select="preceding-sibling::v:shapetype[@id=$shapetype.id]"/>
		</xsl:call-template>
	</xsl:template>
	
	<xsl:template name="add.embedded.textbox">
		<xsl:param name="shape.type" select="/.."/>
		<xsl:choose>
			<xsl:when test="descendant::v:textbox">	
				<dlg:embedded-object>
          <xsl:call-template name="apply.embedded.inline.props"/>
          <xsl:variable name="width">
						<xsl:call-template name="find.substring.attribute">
							<xsl:with-param name="string" select="@style"/>
							<xsl:with-param name="delim" select="';'"/>
							<xsl:with-param name="seperator" select="':'"/>
							<xsl:with-param name="name" select="'width'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:variable name="height">
						<xsl:call-template name="find.substring.attribute">
							<xsl:with-param name="string" select="@style"/>
							<xsl:with-param name="delim" select="';'"/>
							<xsl:with-param name="seperator" select="':'"/>
							<xsl:with-param name="name" select="'height'"/>
						</xsl:call-template>
					</xsl:variable>
					<xsl:attribute name="width">
						<xsl:value-of select="$width"/>
					</xsl:attribute>
					<xsl:attribute name="height">
						<xsl:value-of select="$height"/>
					</xsl:attribute>
					<xsl:apply-templates select="v:textbox">
						<xsl:with-param name="width" select="$width"/>
						<xsl:with-param name="height" select="$height"/>
						<xsl:with-param name="has.border" select="not(@stroked) or @stroked='t'"/>
						<xsl:with-param name="border.weight" select="@strokeweight"/>
						<xsl:with-param name="border.color" select="substring-after(substring-before(@strokecolor, ' '), '#')"/>
						<xsl:with-param name="border.style" select="v:stroke/@dashstyle"/>
						<xsl:with-param name="has.fill" select="@filled='t' or (not(@filled='f') and not($shape.type and $shape.type/@filled='f'))"/>
						<xsl:with-param name="fill" select="v:fill"/>
						<xsl:with-param name="fill.color" select="substring-after(substring-before(@fillcolor, ' '), '#')"/>
						<xsl:with-param name="stroke" select="v:stroke"/>
					</xsl:apply-templates>
				</dlg:embedded-object>
			</xsl:when>
			<xsl:otherwise>
				<xsl:message terminate="no">
					<xsl:text>Unsupported shape found and ignored</xsl:text>
				</xsl:message>
			</xsl:otherwise>		
		</xsl:choose>		
		<xsl:if test="not(contains(@style, 'mso-position-vertical-relative:line'))">
			<xsl:message terminate="no">
				<xsl:text>"In Line with Text" is the only Text Wrapping option supported for embedded objects.  Embedded text box will be placed in line with text</xsl:text>
			</xsl:message>
		</xsl:if>	
	</xsl:template>
	
	<xsl:template match="v:textbox">
		<xsl:param name="width"/>
		<xsl:param name="height"/>
		<xsl:param name="has.border"/>
		<xsl:param name="border.weight"/>
		<xsl:param name="border.color"/>
		<xsl:param name="border.style"/>
		<xsl:param name="has.fill"/>
		<xsl:param name="fill" select="/.."/>
		<xsl:param name="fill.color" select="/.."/>
		<xsl:param name="stroke" select="/.."/>
		<xsl:if test="$stroke and $stroke/@linestyle and ($stroke/@linestyle != 'single')">
			<xsl:message terminate="no">Line styles other than single lines are not supported</xsl:message>
		</xsl:if>
		<xsl:if test="$fill">
			<xsl:message terminate="no">Fill effects are not supported</xsl:message>
		</xsl:if>
		<dlg:text>
			<xsl:call-template name="apply.default.dlg.object.props"/>
			<xsl:if test="$has.border">
				<xsl:attribute name="pen">true</xsl:attribute>
				<xsl:attribute name="pen-style">solid</xsl:attribute>
				<xsl:attribute name="pen-width">1lu</xsl:attribute>
				<xsl:attribute name="pen-color">rgb(0,0,0)</xsl:attribute>
				<xsl:if test="$border.style">
					<xsl:attribute name="pen-style">
						<xsl:call-template name="convert.border.style">
							<xsl:with-param name="border.style" select="$border.style"/>
						</xsl:call-template>
					</xsl:attribute>
				</xsl:if>
				<xsl:if test="$border.weight">
					<xsl:attribute name="pen-width">
						<xsl:value-of select="$border.weight"/>
					</xsl:attribute>
				</xsl:if>
				<xsl:if test="$border.color">
					<xsl:attribute name="pen-color">
						<xsl:call-template name="convert.hex.to.color">
							<xsl:with-param name="hex.color" select="$border.color"/>
						</xsl:call-template>
					</xsl:attribute>
				</xsl:if>
			</xsl:if>
			<xsl:if test="$has.fill and $fill.color">
				<xsl:attribute name="brush">true</xsl:attribute>
				<xsl:attribute name="brush-fill-color">
					<xsl:call-template name="convert.hex.to.color">
						<xsl:with-param name="hex.color" select="$fill.color"/>
					</xsl:call-template>
				</xsl:attribute>
			</xsl:if>
			<dlg:rect>
				<xsl:attribute name="bottom">
					<xsl:value-of select="$height"/>
				</xsl:attribute>
				<xsl:attribute name="right">
					<xsl:value-of select="$width"/>
				</xsl:attribute>
				<xsl:attribute name="left">0.00pt</xsl:attribute>
				<xsl:attribute name="top">0.00pt</xsl:attribute>
			</dlg:rect>
			<xsl:apply-templates select="w:txbxContent">
				<xsl:with-param name="width" select="$width"/>
				<xsl:with-param name="height" select="$height"/>
				<xsl:with-param name="custom.margin" select="@inset"/>
			</xsl:apply-templates>
		</dlg:text>
	</xsl:template>
	
	<xsl:template match="w:txbxContent">
		<xsl:param name="width"/>
		<xsl:param name="height"/>
		<xsl:param name="custom.margin"/>
		<fo:flow>
			<xsl:attribute name="display-align">auto</xsl:attribute>
			<xsl:attribute name="height">
				<xsl:value-of select="$height"/>
			</xsl:attribute>
			<xsl:attribute name="width">
				<xsl:value-of select="$width"/>
			</xsl:attribute>
			<xsl:attribute name="margin-bottom">50.00lu</xsl:attribute>
			<xsl:attribute name="margin-left">100.00lu</xsl:attribute>
			<xsl:attribute name="margin-right">100.00lu</xsl:attribute>
			<xsl:attribute name="margin-top">50.00lu</xsl:attribute>
			<xsl:if test="$custom.margin">
				<xsl:attribute name="margin-left">
					<xsl:value-of select="substring-before($custom.margin, ',')"/>
				</xsl:attribute>
				<xsl:attribute name="margin-top">
					<xsl:value-of select="substring-before(substring-after($custom.margin, ','), ',')"/>
				</xsl:attribute>			
				<xsl:attribute name="margin-right">
					<xsl:variable name="margin.right.string" select="substring-after(substring-after($custom.margin, ','), ',')"/>
					<xsl:choose>
						<xsl:when test="contains($margin.right.string, ',')">
							<xsl:value-of select="substring-before($margin.right.string, ',')"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$margin.right.string"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:attribute>
				<xsl:attribute name="margin-bottom">
					<xsl:value-of select="substring-after(substring-after(substring-after($custom.margin, ','), ','), ',')"/>
				</xsl:attribute>
			</xsl:if>
			<xsl:apply-templates select="*"/>
		</fo:flow>		
	</xsl:template>

	<!-- oMath implementation (just get the text out for now) -->
	<xsl:template match="m:oMathPara">
		<fo:block>
			<xsl:call-template name="apply.math.properties"/>
			<xsl:apply-templates select="*[not(self::m:oMathParaPr)]"/>
		</fo:block>
	</xsl:template>
	
	<xsl:template match="m:oMathParaPr">
		<xsl:apply-templates select="*"/>
	</xsl:template>
	
	<xsl:template match="m:jc">
		<xsl:attribute name="text-align">	
			<xsl:choose>
				<xsl:when test="@m:val='centerGroup'">center</xsl:when>
				<xsl:otherwise>inherit</xsl:otherwise>
			</xsl:choose>
		</xsl:attribute>
	</xsl:template>

	<xsl:template match="m:oMath">
		<xsl:apply-templates select="*"/>
	</xsl:template>
	
	<xsl:template match="m:r">
		<fo:inline>
			<xsl:call-template name="apply.inline.props"/> 
			<xsl:apply-templates select="*[not(self::w:rPr)]"/>
		</fo:inline>
	</xsl:template>
	
	<xsl:template match="m:t">
		<xsl:value-of select="string(.)"/>
	</xsl:template>
	
	<xsl:template match="m:rPr">
	</xsl:template>

	<xsl:template match="m:sty">
	</xsl:template>
	
	<xsl:template name="apply.math.properties">
		<xsl:attribute name="text-align">right</xsl:attribute>
		<xsl:apply-templates select="m:oMathParaPr/*"/>
		<xsl:call-template name="apply.tab.ruler.props"/>
	</xsl:template>

	<!-- ========= HELPER FUNCTIONS ========= -->
	<xsl:template name="convert.hex.to.color">
		<xsl:param name="hex.color"/>
		<xsl:choose>
			<xsl:when test="$hex.color='auto'">rgb(0,0,0)</xsl:when>
			<xsl:when test="$hex.color='black'">rgb(0,0,0)</xsl:when>
			<xsl:when test="$hex.color='blue'">rgb(0,0,255)</xsl:when>
			<xsl:when test="$hex.color='cyan'">rgb(0,255,255)</xsl:when>
			<xsl:when test="$hex.color='darkBlue'">rgb(0,0,139)</xsl:when>
			<xsl:when test="$hex.color='darkCyan'">rgb(0,139,139)</xsl:when>
			<xsl:when test="$hex.color='darkGray'">rgb(169,169,169)</xsl:when>
			<xsl:when test="$hex.color='darkGreen'">rgb(0,100,0)</xsl:when>
			<xsl:when test="$hex.color='darkMagenta'">rgb(128,0,128)</xsl:when>
			<xsl:when test="$hex.color='darkRed'">rgb(139,0,0)</xsl:when>
			<xsl:when test="$hex.color='darkYellow'">rgb(128,128,0)</xsl:when>
			<xsl:when test="$hex.color='green'">rgb(0,255,0)</xsl:when>
			<xsl:when test="$hex.color='lightGray'">rgb(211,211,211)</xsl:when>
			<xsl:when test="$hex.color='magenta'">rgb(255,0,255)</xsl:when>
			<xsl:when test="$hex.color='red'">rgb(255,0,0)</xsl:when>
			<xsl:when test="$hex.color='white'">rgb(255,255,255)</xsl:when>
			<xsl:when test="$hex.color='yellow'">rgb(255,255,0)</xsl:when>
			<!-- don't bother parsing common colors -->
			<xsl:when test="$hex.color='000000'">rgb(0,0,0)</xsl:when>
			<xsl:when test="$hex.color='FFFFFF'">rgb(255,255,255)</xsl:when>
			<xsl:when test="$hex.color='0000FF'">rgb(0,0,255)</xsl:when>
			<xsl:when test="$hex.color='00FF00'">rgb(0,255,0)</xsl:when>
			<xsl:when test="$hex.color='FF0000'">rgb(255,0,0)</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="color.hex.r">
					<xsl:call-template name="extract.red.hex">
						<xsl:with-param name="hex.color" select="$hex.color"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="color.hex.g">
					<xsl:call-template name="extract.green.hex">
						<xsl:with-param name="hex.color" select="$hex.color"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="color.hex.b">
					<xsl:call-template name="extract.blue.hex">
						<xsl:with-param name="hex.color" select="$hex.color"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="color.dec.r">
					<xsl:call-template name="convert.hex.byte.to.number">
						<xsl:with-param name="byte" select="$color.hex.r"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="color.dec.g">
					<xsl:call-template name="convert.hex.byte.to.number">
						<xsl:with-param name="byte" select="$color.hex.g"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="color.dec.b">
					<xsl:call-template name="convert.hex.byte.to.number">
						<xsl:with-param name="byte" select="$color.hex.b"/>
					</xsl:call-template>
				</xsl:variable>
				<!-- takes the form rgb(255,255,255) -->
				<xsl:value-of select="concat('rgb(', $color.dec.r, ',', $color.dec.g, ',', $color.dec.b, ')')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- converts a given hex color value, e.g., #c0504d, to a HSL value, e.g., hsl();
         thanks to http://serennu.com/colour/rgbtohsl.php -->
	<xsl:template name="convert.hex.to.hsl">
		<xsl:param name="hex.color"/>
		<!-- Hex parts of given hex color: -->
		<xsl:variable name="color.hex.r">
			<xsl:call-template name="extract.red.hex">
				<xsl:with-param name="hex.color" select="$hex.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.hex.g">
			<xsl:call-template name="extract.green.hex">
				<xsl:with-param name="hex.color" select="$hex.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.hex.b">
			<xsl:call-template name="extract.blue.hex">
				<xsl:with-param name="hex.color" select="$hex.color"/>
			</xsl:call-template>
		</xsl:variable>
		<!-- RGB decimal conversions of hex parts: -->
		<xsl:variable name="color.dec.r">
			<xsl:call-template name="convert.hex.byte.to.number">
				<xsl:with-param name="byte" select="$color.hex.r"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.dec.g">
			<xsl:call-template name="convert.hex.byte.to.number">
				<xsl:with-param name="byte" select="$color.hex.g"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.dec.b">
			<xsl:call-template name="convert.hex.byte.to.number">
				<xsl:with-param name="byte" select="$color.hex.b"/>
			</xsl:call-template>
		</xsl:variable>
		<!-- Convert decimals in 0-255 range to 0-1 range: -->
		<xsl:variable name="color.pct.r" select="$color.dec.r div 255"/>
		<xsl:variable name="color.pct.g" select="$color.dec.g div 255"/>
		<xsl:variable name="color.pct.b" select="$color.dec.b div 255"/>
		<!-- Max, min, and difference between max/min: -->
		<xsl:variable name="color.pct.min">
			<xsl:call-template name="min.of.three">
				<xsl:with-param name="v1" select="$color.pct.r"/>
				<xsl:with-param name="v2" select="$color.pct.g"/>
				<xsl:with-param name="v3" select="$color.pct.b"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.pct.max">
			<xsl:call-template name="max.of.three">
				<xsl:with-param name="v1" select="$color.pct.r"/>
				<xsl:with-param name="v2" select="$color.pct.g"/>
				<xsl:with-param name="v3" select="$color.pct.b"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="color.pct.spread" select="$color.pct.max - $color.pct.min"/>
		<!-- Luminance: -->
		<xsl:variable name="color.hsl.l" select="($color.pct.max + $color.pct.min) div 2"/>
		<!-- Hue, possibly outside 0-1 range: -->
		<xsl:variable name="color.hsl.h.tmp">
			<xsl:choose>
				<xsl:when test="$color.pct.spread = 0">
					<xsl:value-of select="0"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:variable name="color.pct.r.spread" select="((($color.pct.max - $color.pct.r) div 6) + ($color.pct.spread div 2)) div $color.pct.spread"/>
					<xsl:variable name="color.pct.g.spread" select="((($color.pct.max - $color.pct.g) div 6) + ($color.pct.spread div 2)) div $color.pct.spread"/>
					<xsl:variable name="color.pct.b.spread" select="((($color.pct.max - $color.pct.b) div 6) + ($color.pct.spread div 2)) div $color.pct.spread"/>
					<xsl:variable name="color.pct.max.round" select="round($color.pct.max * 100)"/>
					<xsl:variable name="color.pct.r.round" select="round($color.pct.r * 100)"/>
					<xsl:variable name="color.pct.g.round" select="round($color.pct.g * 100)"/>
					<xsl:variable name="color.pct.b.round" select="round($color.pct.b * 100)"/>
					<xsl:choose>
						<!-- Red value is max: -->
						<xsl:when test="$color.pct.r.round = $color.pct.max.round">
							<xsl:value-of select="$color.pct.b.spread - $color.pct.g.spread"/>
						</xsl:when>
						<!-- Green value is max: -->
						<xsl:when test="$color.pct.g.round = $color.pct.max.round">
							<xsl:value-of select="(1 div 3) + $color.pct.r.spread - $color.pct.b.spread"/>
						</xsl:when>
						<!-- Blue value is max: -->
						<xsl:when test="$color.pct.b.round = $color.pct.max.round">
							<xsl:value-of select="(2 div 3) + $color.pct.g.spread - $color.pct.r.spread"/>
						</xsl:when>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable><!--color.hsl.h.tmp-->
		<!-- Hue: -->
		<xsl:variable name="color.hsl.h">
			<xsl:choose>
				<xsl:when test="$color.hsl.h.tmp &lt; 0">
					<xsl:value-of select="$color.hsl.h.tmp + 1"/>
				</xsl:when>
				<xsl:when test="$color.hsl.h.tmp &gt; 1">
					<xsl:value-of select="$color.hsl.h.tmp - 1"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$color.hsl.h.tmp"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable><!--color.hsl.h-->
		<!-- Saturation: -->
		<xsl:variable name="color.hsl.s">
			<xsl:choose>
				<xsl:when test="$color.hsl.l &lt; 0.5">
					<xsl:value-of select="$color.pct.spread div ($color.pct.max + $color.pct.min)"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$color.pct.spread div (2 - $color.pct.max - $color.pct.min)"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable><!--color.hsl.s-->
		<xsl:variable name="color.hsl.h.rounded">
			<xsl:call-template name="round.to.two.decimals">
				<xsl:with-param name="float.num" select="$color.hsl.h"/>
			</xsl:call-template>
		</xsl:variable><!--color.hsl.h.rounded-->
		<xsl:variable name="color.hsl.s.rounded">
			<xsl:call-template name="round.to.two.decimals">
				<xsl:with-param name="float.num" select="$color.hsl.s"/>
			</xsl:call-template>
		</xsl:variable><!--color.hsl.s.rounded-->
		<xsl:variable name="color.hsl.l.rounded">
			<xsl:call-template name="round.to.two.decimals">
				<xsl:with-param name="float.num" select="$color.hsl.l"/>
			</xsl:call-template>
		</xsl:variable><!--color.hsl.l.rounded-->
		<!-- takes the form hsl(0.0,0.0,0.0) where each element ranges between 0-1 -->
		<xsl:value-of select="concat('hsl(', $color.hsl.h.rounded, ',', $color.hsl.s.rounded, ',', $color.hsl.l.rounded, ')')"/>
	</xsl:template>
	
	<xsl:template name="round.to.two.decimals">
		<xsl:param name="float.num"/>
		<!-- format-number() is an XSLT 2 function -->
		<xsl:value-of select="round(100*$float.num) div 100"/>
	</xsl:template>
	
	<xsl:template name="max.of.three">
		<xsl:param name="v1"/>
		<xsl:param name="v2"/>
		<xsl:param name="v3"/>
		<xsl:choose>
			<xsl:when test="$v1 &gt; $v2 and $v1 &gt; $v3">
				<xsl:value-of select="$v1"/>
			</xsl:when>
			<xsl:when test="$v2 &gt; $v1 and $v2 &gt; $v3">
				<xsl:value-of select="$v2"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$v3"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="min.of.three">
		<xsl:param name="v1"/>
		<xsl:param name="v2"/>
		<xsl:param name="v3"/>
		<xsl:choose>
			<xsl:when test="$v1 &lt; $v2 and $v1 &lt; $v3">
				<xsl:value-of select="$v1"/>
			</xsl:when>
			<xsl:when test="$v2 &lt; $v1 and $v2 &lt; $v3">
				<xsl:value-of select="$v2"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$v3"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- given an HSL color of the form hsl(0.1,0.2,0.3), extracts the hue part,
         e.g., 0.1 -->
	<xsl:template name="extract.h.hsl">
		<xsl:param name="hsl.color"/>
		<xsl:call-template name="extract.one.third">
			<xsl:with-param name="segment_num" select="1"/>
			<xsl:with-param name="str" select="$hsl.color"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given an HSL color of the form hsl(0.1,0.2,0.3), extracts the saturation
         part, e.g., 0.2 -->
	<xsl:template name="extract.s.hsl">
		<xsl:param name="hsl.color"/>
		<xsl:call-template name="extract.one.third">
			<xsl:with-param name="segment_num" select="2"/>
			<xsl:with-param name="str" select="$hsl.color"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given an HSL color of the form hsl(0.1,0.2,0.3), extracts the luminance
         part, e.g., 0.3 -->
	<xsl:template name="extract.l.hsl">
		<xsl:param name="hsl.color"/>
		<xsl:call-template name="extract.one.third">
			<xsl:with-param name="segment_num" select="3"/>
			<xsl:with-param name="str" select="$hsl.color"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given a value like kkk(x,y,z) and a number between 1 and 3 inclusive,
         this will return the corresponding x, y, or z value from that string
         based on the given number -->
	<xsl:template name="extract.one.third">
		<xsl:param name="str"/><!-- e.g., hsl(0.1,0.2,0.3) -->
		<xsl:param name="segment_num"/>
		<xsl:variable name="first_and_beginning" select="substring-before($str, ',')"/><!-- hsl(0.1 -->
		<xsl:variable name="first" select="substring-after($first_and_beginning, '(')"/><!-- 0.1 -->
		<xsl:variable name="second_third_end" select="substring($str, string-length($first_and_beginning)+2)"/><!-- 0.2,0.3) -->
		<xsl:variable name="second" select="substring-before($second_third_end, ',')"/><!-- 0.2 -->
		<xsl:variable name="third_end" select="substring($second_third_end, string-length($second)+2)"/><!-- 0.3) -->
		<xsl:variable name="third" select="substring-before($third_end, ')')"/><!-- 0.3 -->
		<xsl:choose>
			<xsl:when test="$segment_num = 1">
				<xsl:value-of select="$first"/>
			</xsl:when>
			<xsl:when test="$segment_num = 2">
				<xsl:value-of select="$second"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$third"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- given a hex value like 66 as a shade and another hex value like 4f81bd as
         a full RRGGBB color, this will apply that shade to the color -->
	<xsl:template name="convert.hex.to.shaded.hex">
		<xsl:param name="color.theme.shade.hex"/><!-- e.g., 66 -->
		<xsl:param name="color.theme.hex"/><!-- e.g., 4f81bd -->
		
		<!-- percentage in 0-1 range: -->
		<xsl:variable name="color.theme.shade.pct">
			<xsl:call-template name="convert.hex.to.rgb.pct">
				<xsl:with-param name="hex.byte" select="$color.theme.shade.hex"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Convert hex theme color to HSL value: -->
		<xsl:variable name="color.theme.hsl">
			<xsl:call-template name="convert.hex.to.hsl">
				<xsl:with-param name="hex.color" select="$color.theme.hex"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Luminance from theme color: -->
		<xsl:variable name="color.theme.hsl.l">
			<xsl:call-template name="extract.l.hsl">
				<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:call-template name="convert.hsl.to.hex">
			<xsl:with-param name="hue">
				<xsl:call-template name="extract.h.hsl">
					<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
				</xsl:call-template>
			</xsl:with-param>
			<xsl:with-param name="saturation">
				<xsl:call-template name="extract.s.hsl">
					<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
				</xsl:call-template>
			</xsl:with-param>
			<!-- Luminance, adjusted for shade: -->
			<xsl:with-param name="luminance" select="$color.theme.hsl.l * $color.theme.shade.pct"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given a hex byte, e.g., 6f, this will convert that to a floating point
         in the range 0-1, e.g., 0.4353, representing where the RGB color value,
         e.g., 111, lies in the 0-255 range -->
	<xsl:template name="convert.hex.to.rgb.pct">
		<xsl:param name="hex.byte"/>
		
		<!-- Convert hex tint to a decimal between 0-255 -->
		<xsl:variable name="rgb.number">
			<xsl:call-template name="convert.hex.byte.to.number">
				<xsl:with-param name="byte" select="$hex.byte"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- 0-255 decimal to floating point range 0-1: -->
		<xsl:value-of select="$rgb.number div 255"/>
	</xsl:template>

	<!-- given a hex value like 66 as a tint and another hex value like 4f81bd as
         a full RRGGBB color, this will apply that tint to the color -->
	<xsl:template name="convert.hex.to.tinted.hex">
		<xsl:param name="color.theme.tint.hex"/><!-- e.g., 66 -->
		<xsl:param name="color.theme.hex"/><!-- e.g., 4f81bd -->
		
		<!-- percentage in 0-1 range: -->
		<xsl:variable name="color.theme.tint.pct">
			<xsl:call-template name="convert.hex.to.rgb.pct">
				<xsl:with-param name="hex.byte" select="$color.theme.tint.hex"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Convert hex theme color to HSL value: -->
		<xsl:variable name="color.theme.hsl">
			<xsl:call-template name="convert.hex.to.hsl">
				<xsl:with-param name="hex.color" select="$color.theme.hex"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Luminance from theme color: -->
		<xsl:variable name="color.theme.hsl.l">
			<xsl:call-template name="extract.l.hsl">
				<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:call-template name="convert.hsl.to.hex">
			<xsl:with-param name="hue">
				<xsl:call-template name="extract.h.hsl">
					<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
				</xsl:call-template>
			</xsl:with-param>
			<xsl:with-param name="saturation">
				<xsl:call-template name="extract.s.hsl">
					<xsl:with-param name="hsl.color" select="$color.theme.hsl"/>
				</xsl:call-template>
			</xsl:with-param>
			<!-- Luminance, adjusted for tint: -->
			<xsl:with-param name="luminance" select="($color.theme.hsl.l * $color.theme.tint.pct) + (1 - $color.theme.tint.pct)"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given separate hue, saturation, and luminance values, this will produce
         the hex color code equivalent -->
	<xsl:template name="convert.hsl.to.hex">
		<xsl:param name="hue"/>
		<xsl:param name="saturation"/>
		<xsl:param name="luminance"/>
		
		<xsl:variable name="hsl_str" select="concat('hsl(', $hue, ',', $saturation, ',', $luminance, ')')"/>
		
		<!-- Convert new HSL value into RGB: -->
		<xsl:variable name="rgb_str">
			<xsl:call-template name="convert.hsl.to.rgb">
				<xsl:with-param name="hsl.color" select="$hsl_str"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Convert new RGB value into a hex color: -->
		<xsl:call-template name="convert.rgb.to.hex">
			<xsl:with-param name="rgb.color" select="$rgb_str"/>
		</xsl:call-template>
	</xsl:template>
	
	<!-- given a color expressed as hsl(x,y,z), such as hsl(0.59,0.45,0.53), this
         will calculate the equivalent RGB color, such as rgb(81,130,189) -->
	<xsl:template name="convert.hsl.to.rgb">
		<xsl:param name="hsl.color"/>
		
		<!-- Extract individual h, s, l components: -->
		<xsl:variable name="hsl.color.h">
			<xsl:call-template name="extract.h.hsl">
				<xsl:with-param name="hsl.color" select="$hsl.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="hsl.color.s">
			<xsl:call-template name="extract.s.hsl">
				<xsl:with-param name="hsl.color" select="$hsl.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="hsl.color.l">
			<xsl:call-template name="extract.l.hsl">
				<xsl:with-param name="hsl.color" select="$hsl.color"/>
			</xsl:call-template>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="$hsl.color.s = 0">
				<xsl:variable name="single_hsl_value" select="$hsl.color.l * 255"/>
				<xsl:value-of select="concat('rgb(', $single_hsl_value, ',', $single_hsl_value, ',', $single_hsl_value, ')')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="var2">
					<xsl:choose>
						<xsl:when test="$hsl.color.l &lt; 0.5">
							<xsl:value-of select="$hsl.color.l * (1 + $hsl.color.s)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="($hsl.color.l + $hsl.color.s) - ($hsl.color.s * $hsl.color.l)"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:variable name="var1" select="(2 * $hsl.color.l) - $var2"/>
				<xsl:variable name="rgb.color.r">
					<xsl:call-template name="convert.hue.to.rgb">
						<xsl:with-param name="v1" select="$var1"/>
						<xsl:with-param name="v2" select="$var2"/>
						<xsl:with-param name="vh" select="$hsl.color.h + (1 div 3)"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="rgb.color.g">
					<xsl:call-template name="convert.hue.to.rgb">
						<xsl:with-param name="v1" select="$var1"/>
						<xsl:with-param name="v2" select="$var2"/>
						<xsl:with-param name="vh" select="$hsl.color.h"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="rgb.color.b">
					<xsl:call-template name="convert.hue.to.rgb">
						<xsl:with-param name="v1" select="$var1"/>
						<xsl:with-param name="v2" select="$var2"/>
						<xsl:with-param name="vh" select="$hsl.color.h - (1 div 3)"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="rgb.color.str.r" select="round(255 * $rgb.color.r)"/>
				<xsl:variable name="rgb.color.str.g" select="round(255 * $rgb.color.g)"/>
				<xsl:variable name="rgb.color.str.b" select="round(255 * $rgb.color.b)"/>
				<xsl:value-of select="concat('rgb(', $rgb.color.str.r, ',', $rgb.color.str.g, ',', $rgb.color.str.b, ')')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- converts a hue to a RGB value; thanks to http://serennu.com/colour/rgbtohsl.php -->
	<xsl:template name="convert.hue.to.rgb">
		<xsl:param name="v1"/>
		<xsl:param name="v2"/>
		<xsl:param name="vh"/>
		
		<xsl:variable name="adjusted_vh">
			<xsl:choose>
				<xsl:when test="$vh &lt; 0">
					<xsl:value-of select="$vh + 1"/>
				</xsl:when>
				<xsl:when test="$vh &gt; 1">
					<xsl:value-of select="$vh - 1"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$vh"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		
		<xsl:choose>
			<xsl:when test="(6 * $adjusted_vh) &lt; 1">
				<xsl:value-of select="$v1 + ($v2 - $v1) * 6 * $adjusted_vh"/>
			</xsl:when>
			<xsl:when test="(2 * $adjusted_vh) &lt; 1">
				<xsl:value-of select="$v2"/>
			</xsl:when>
			<xsl:when test="(3 * $adjusted_vh) &lt; 2">
				<xsl:value-of select="$v1 + ($v2 - $v1) * (((2 div 3) - $vh) * 6)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$v1"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="convert.rgb.to.hex">
		<xsl:param name="rgb.color"/>
		
		<!-- Extract individual components of the RGB color: -->
		<xsl:variable name="rgb.color.r">
			<xsl:call-template name="extract.one.third">
				<xsl:with-param name="segment_num" select="1"/>
				<xsl:with-param name="str" select="$rgb.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="rgb.color.g">
			<xsl:call-template name="extract.one.third">
				<xsl:with-param name="segment_num" select="2"/>
				<xsl:with-param name="str" select="$rgb.color"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="rgb.color.b">
			<xsl:call-template name="extract.one.third">
				<xsl:with-param name="segment_num" select="3"/>
				<xsl:with-param name="str" select="$rgb.color"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Convert those components from 0-255 decimals to hexadecimal values: -->
		<xsl:variable name="hex.color.r">
			<xsl:call-template name="convert.color.int.to.hex">
				<xsl:with-param name="num" select="$rgb.color.r"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="hex.color.g">
			<xsl:call-template name="convert.color.int.to.hex">
				<xsl:with-param name="num" select="$rgb.color.g"/>
			</xsl:call-template>
		</xsl:variable>
		<xsl:variable name="hex.color.b">
			<xsl:call-template name="convert.color.int.to.hex">
				<xsl:with-param name="num" select="$rgb.color.b"/>
			</xsl:call-template>
		</xsl:variable>
		
		<!-- Combine them all into one hex color string, e.g., 0044ff: -->
		<xsl:value-of select="concat($hex.color.r, $hex.color.g, $hex.color.b)"/>
	</xsl:template>
	
	<xsl:template name="convert.color.int.to.hex">
		<xsl:param name="num"/>
		
		<xsl:choose>
			<xsl:when test="boolean($num)">
				<xsl:choose>
					<xsl:when test="$num = 0">00</xsl:when>
					<xsl:otherwise>
						<xsl:variable name="max">
							<xsl:choose>
								<xsl:when test="0 &gt; $num">0</xsl:when>
								<xsl:otherwise><xsl:value-of select="$num"/></xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="min_max">
							<xsl:choose>
								<xsl:when test="$max &lt; 255"><xsl:value-of select="$max"/></xsl:when>
								<xsl:otherwise>255</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="hex_chars" select="'0123456789ABCDEF'"/>
						<xsl:variable name="index1" select="(($min_max - $min_max mod 16) div 16) + 1"/>
						<xsl:variable name="index2" select="($min_max mod 16) + 1"/>
						<xsl:variable name="char1" select="substring($hex_chars, $index1, 1)"/>
						<xsl:variable name="char2" select="substring($hex_chars, $index2, 1)"/>
						<xsl:value-of select="concat($char1, $char2)"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>00</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- select just the red part of a hex color code, e.g., 00 of #00ffaa -->
	<xsl:template name="extract.red.hex">
		<xsl:param name="hex.color"/>
		<xsl:choose>
			<xsl:when test="string-length($hex.color) = 3">
				<xsl:value-of select="concat(substring($hex.color, 1, 1), substring($hex.color, 1, 1))"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="substring($hex.color, 1, 2)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- select just the green part of a hex color code, e.g., ff of #00ffaa -->
	<xsl:template name="extract.green.hex">
		<xsl:param name="hex.color"/>
		<xsl:choose>
			<xsl:when test="string-length($hex.color) = 3">
				<xsl:value-of select="concat(substring($hex.color, 2, 1), substring($hex.color, 2, 1))"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="substring($hex.color, 3, 2)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- select just the blue part of a hex color code, e.g., aa of #00ffaa -->
	<xsl:template name="extract.blue.hex">
		<xsl:param name="hex.color"/>
		<xsl:choose>
			<xsl:when test="string-length($hex.color) = 3">
				<xsl:value-of select="concat(substring($hex.color, 3, 1), substring($hex.color, 3, 1))"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="substring($hex.color, 5, 2)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- convert single digit hex value to number, example F = 15 -->
	<xsl:template name="convert.hex.byte.to.number">
		<xsl:param name="byte"/>
		<xsl:variable name="val1">
			<xsl:call-template name="convert.hex.to.number">
				<xsl:with-param name="hex" select="substring($byte, 1, 1)"/>
			</xsl:call-template>		
		</xsl:variable>
		<xsl:variable name="val2">
			<xsl:call-template name="convert.hex.to.number">
				<xsl:with-param name="hex" select="substring($byte, 2, 1)"/>
			</xsl:call-template>		
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$val2 != ''">
				<xsl:value-of select="number((16 * $val1) + $val2)"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="number($val1)"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="convert.hex.to.number">
		<xsl:param name="hex"/>
		<xsl:choose>
			<xsl:when test="$hex = 'a' or $hex = 'A'">10</xsl:when>
			<xsl:when test="$hex = 'b' or $hex = 'B'">11</xsl:when>
			<xsl:when test="$hex = 'c' or $hex = 'C'">12</xsl:when>
			<xsl:when test="$hex = 'd' or $hex = 'D'">13</xsl:when>
			<xsl:when test="$hex = 'e' or $hex = 'E'">14</xsl:when>
			<xsl:when test="$hex = 'f' or $hex = 'F'">15</xsl:when>
			<xsl:otherwise><xsl:value-of select="$hex"/></xsl:otherwise>
		</xsl:choose>	
	</xsl:template>

	<xsl:template name="convert.resolution">
		<xsl:param name="res.from"/>
		<!-- this gets called an awful lot, let's be smarter about the calculation 
		<xsl:variable name="dxf.resolution" select="1000"/>
		<xsl:variable name="docx.resolution" select="1440"/>
		-->
		<xsl:variable name="res.to" select="($res.from * 1000) div 1440"/>
		<xsl:value-of select="concat($res.to, 'lu')"/>
	</xsl:template>

  <xsl:template name="convert.resolution.number">
    <xsl:param name="res.from"/>
    <!-- this gets called an awful lot, let's be smarter about the calculation 
		<xsl:variable name="dxf.resolution" select="1000"/>
		<xsl:variable name="docx.resolution" select="1440"/>
		-->
    <xsl:value-of select="($res.from * 1000) div 1440"/>
  </xsl:template>

  <xsl:template name="try.sum.lu">
		<xsl:param name="init_value"/>
		<xsl:param name="amount"/>
		<xsl:param name="stay_positive"/>
		
		<xsl:variable name="adjusted_value">
			<xsl:call-template name="sum.lu">
				<xsl:with-param name="val1" select="$init_value"/>
				<xsl:with-param name="val2" select="$amount"/>
			</xsl:call-template>
		</xsl:variable>
		 <xsl:variable name="normalized_value">
			<xsl:choose>
				<xsl:when test="$stay_positive and substring-before($adjusted_value, 'lu') &lt; 0">0lu</xsl:when>
				<xsl:otherwise><xsl:value-of select="$adjusted_value"/></xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$normalized_value != 'NaNlu'">
				<xsl:value-of select="$normalized_value"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$init_value"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Given strings like 250lu and 500.00lu, this will sum them to an answer
		 like 750lu. -->
	<xsl:template name="sum.lu">
		<xsl:param name="val1"/>
		<xsl:param name="val2"/>
		<xsl:variable name="val1_num">
			<xsl:choose>
				<xsl:when test="contains($val1, 'lu')">
					<xsl:value-of select="substring-before($val1, 'lu')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$val1"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="val2_num">
			<xsl:choose>
				<xsl:when test="contains($val2, 'lu')">
					<xsl:value-of select="substring-before($val2, 'lu')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="$val2"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:value-of select="concat($val1_num + $val2_num, 'lu')"/>
	</xsl:template>
	
	<xsl:template name="convert.border.style">
		<xsl:param name="border.style"/>
		<xsl:choose>
			<xsl:when test="$border.style = 'none' or $border.style = 'nil'">
				<xsl:value-of select="'none'"/>
			</xsl:when>
			<xsl:when test="$border.style = 'single'">
				<xsl:value-of select="'solid'"/>
			</xsl:when>
			<xsl:when test="$border.style = 'dashSmallGap'">
				<xsl:value-of select="'shortdashed'"/>
			</xsl:when>
			<xsl:when test="($border.style = 'dashed') or ($border.style = 'dash')">
				<xsl:value-of select="'dashed'"/>
			</xsl:when>
			<xsl:when test="$border.style = 'dotted'">
				<xsl:value-of select="'dotted'"/>
			</xsl:when>
			<xsl:when test="$border.style = 'double'">
				<xsl:message terminate="no">
					<xsl:text>Double table cell border is not supported.  Single will be used</xsl:text>
				</xsl:message>
				<xsl:value-of select="'solid'"/>
				<!-- <xsl:value-of select="'double'"/> -->
			</xsl:when>
			<xsl:when test="$border.style = 'inset'">
				<xsl:message terminate="no">
					<xsl:text>Inset table cell border is not supported.  Single will be used</xsl:text>
				</xsl:message>
				<xsl:value-of select="'solid'"/>
				<!-- <xsl:value-of select="'inset'"/> -->
			</xsl:when>
			<xsl:when test="$border.style = 'outset'">
				<xsl:message terminate="no">
					<xsl:text>Outset table cell border is not supported.  Single will be used</xsl:text>
				</xsl:message>
				<xsl:value-of select="'solid'"/>
				<!-- <xsl:value-of select="'outset'"/> -->
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'solid'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="convert.table.width.prop">
		<xsl:param name="type" select="auto"/>
		<xsl:param name="value" select="0"/>
		<xsl:choose>
			<xsl:when test="$type='nil' or $type='dxa'">
				<xsl:call-template name="convert.resolution">
					<xsl:with-param name="res.from" select="$value"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:when test="$type='pct'"><xsl:value-of select="$value div 50"/><xsl:text>%</xsl:text></xsl:when>
			<xsl:otherwise><xsl:text>auto</xsl:text></xsl:otherwise>
		</xsl:choose>	
	</xsl:template>
	
	<xsl:template name="count.rows.spanned">
		<xsl:param name="num.cells.spanned"/>
		<xsl:param name="next.cell"/>
		<xsl:param name="col.num"/>
		<xsl:choose>
			<xsl:when test="$next.cell/w:tcPr/w:vMerge[not(@w:val='restart')]">
				<xsl:call-template name="count.rows.spanned">
					<xsl:with-param name="num.cells.spanned" select="$num.cells.spanned + 1"/>
					<xsl:with-param name="next.cell" select="$next.cell/ancestor::w:tr[1]/following-sibling::w:tr[1]/w:tc[count(.|preceding-sibling::w:tc[not(w:tcPr/w:gridSpan)]) + sum(preceding-sibling::w:tc/w:tcPr/w:gridSpan/@w:val) = $col.num]"/>
					<xsl:with-param name="col.num" select="$col.num"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="number-rows-spanned">
					<xsl:value-of select="$num.cells.spanned"/>
				</xsl:attribute>
				<xsl:if test="$num.cells.spanned > 1">
					<xsl:message terminate="no">
						<xsl:text>Dialogue tables do not support row spanning</xsl:text>
					</xsl:message>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>	

	<xsl:template name="count.cols.spanned">
		<xsl:param name="num.cells.spanned"/>
		<xsl:param name="next.cell"/>
		<xsl:choose>
			<xsl:when test="$next.cell/w:tcPr/w:hMerge[not(@w:val='restart')]">
				<xsl:call-template name="count.cols.spanned">
					<xsl:with-param name="num.cells.spanned" select="$num.cells.spanned + 1"/>
					<xsl:with-param name="next.cell" select="$next.cell/following-sibling::w:tc[1]"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:attribute name="number-columns-spanned">
					<xsl:value-of select="$num.cells.spanned"/>
				</xsl:attribute>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="should.apply.conditional.formatting">
		<xsl:param name="bitmask" />
		<xsl:param name="value" />
		<xsl:variable name="dec.value" select="translate($value,'0','')"/>
		<xsl:variable name="pos.value" select="string-length(substring-before($value,$dec.value))+1"/>
		<xsl:variable name="dec.in.bitmask" select="number(substring-before(substring-after('00/11/22/33/44/55/66/77/88/99/A10/B11/C12/D13/E14/F15/a10/b11/c12/d13/e14/f15/',substring($bitmask,$pos.value,1)),'/'))"/>
		<xsl:choose>
			<xsl:when test="$dec.value=(8 or 4 or 2 or 1) and string-length($bitmask)=4 and $pos.value &gt;=1 and $pos.value &lt;=4 and not(string($dec.in.bitmask)='NaN')">
				<xsl:value-of select="($dec.in.bitmask mod (2*$dec.value)) >= $dec.value"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>false</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
    <xsl:template name="non-empty.token.count">
        <xsl:param name="text"/>
        <xsl:param name="separator"/>
        <xsl:param name="count_so_far" select="0"/>
        
        <xsl:choose>
            <xsl:when test="not(contains($text, $separator))">
				<xsl:choose>
					<xsl:when test="$text = ''">
						<xsl:value-of select="$count_so_far"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$count_so_far + 1"/>
					</xsl:otherwise>
				</xsl:choose>
            </xsl:when>
            <xsl:otherwise>
				<xsl:variable name="next_token" select="substring-after($text, $separator)"/>
				<xsl:variable name="cur_token" select="substring-before($text, $separator)"/>
                <xsl:call-template name="non-empty.token.count">
                    <xsl:with-param name="text" select="$next_token"/>
                    <xsl:with-param name="separator" select="$separator"/>
                    <xsl:with-param name="count_so_far">
						<xsl:choose>
							<xsl:when test="$cur_token = ''">
								<xsl:value-of select="$count_so_far"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$count_so_far + 1"/>
							</xsl:otherwise>
						</xsl:choose>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- Given a string, a separator string, and a key string, this will select
		 a substring of the given string where each token of the string (as
		 determined by the given separator) has the key string within it.  Ex.:
		 'Article %1' as string, ' ' as separator, and '%' as key results in '%1'. -->
	<xsl:template name="strip-tokens-without-key">
		<xsl:param name="text"/>
		<xsl:param name="separator"/>
		<xsl:param name="key"/>
		<xsl:param name="string_so_far" select="''"/>
		
        <xsl:choose>
            <xsl:when test="not(contains($text, $separator))">
				<xsl:choose>
					<xsl:when test="contains($text, $key)">
						<xsl:choose>
							<xsl:when test="$string_so_far = ''">
								<xsl:value-of select="$text"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="concat($string_so_far, $separator, $text)"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$string_so_far"/>
					</xsl:otherwise>
				</xsl:choose>
            </xsl:when>
            <xsl:otherwise>
				<xsl:variable name="next_token" select="substring-after($text, $separator)"/>
				<xsl:variable name="cur_token" select="substring-before($text, $separator)"/>
                <xsl:call-template name="strip-tokens-without-key">
                    <xsl:with-param name="text" select="$next_token"/>
                    <xsl:with-param name="separator" select="$separator"/>
                    <xsl:with-param name="key" select="$key"/>
                    <xsl:with-param name="string_so_far">
						<xsl:choose>
							<xsl:when test="contains($cur_token, $key)">
								<xsl:choose>
									<xsl:when test="$string_so_far = ''">
										<xsl:value-of select="$cur_token"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="concat($string_so_far, $separator, $cur_token)"/>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$string_so_far"/>
							</xsl:otherwise>
						</xsl:choose>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
	</xsl:template>
	
	<!-- Given a Docx number format like 'upperLetter' or 'decimal', this will
		 convert that to a DXF list-type, like 'bullet' or 'number'. The given
		 abstract_num_id must have a value, otherwise the list-type will be 'none'. -->
	<xsl:template name="numFmt2list-type">
		<xsl:param name="numFmt"/>
		<xsl:param name="abstract_num_id"/>
		<xsl:param name="num_id"/>
		<xsl:choose>
			<!-- When we have an abstractNum (which we got via a good numId) or when we
				 don't have an abstractNum but we also don't have a good numId, we need
				 a list. Have an abstractNum? Then we had a good numId, implying a list.
				 Have no numId but we're still here? Must have had a 'Chapter %1'-style
				 list that we need to support. -->
			<xsl:when test="boolean($abstract_num_id) or not(boolean($num_id))">
				<xsl:variable name="number-type">
					<xsl:call-template name="numFmtAndLvlText2number-type">
						<xsl:with-param name="numFmt" select="$numFmt"/>
						<xsl:with-param name="lvlText" select="'%1'"/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="$number-type = 'bullet'">bullet</xsl:when>
					<xsl:otherwise>number</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>none</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- Given a Docx number format like 'upperLetter' and a level text like
		 '%1)', this will convert that to a DXF number-type like
		 'alpha-upper-paren'. -->
	<xsl:template name="numFmtAndLvlText2number-type">
		<xsl:param name="numFmt"/>
		<xsl:param name="lvlText"/>
		
		<xsl:variable name="has_start_paren" select="substring($lvlText, 1, 1) = '('"/>
		<xsl:variable name="has_end_paren" select="substring($lvlText, string-length($lvlText)) = ')'"/>
		<xsl:variable name="single_paren" select="$has_end_paren and not($has_start_paren)"/>
		<xsl:variable name="double_paren" select="$has_start_paren and $has_end_paren"/>
		
		<xsl:variable name="is_upper_letter" select="$numFmt = 'upperLetter'"/>
		<xsl:variable name="is_lower_letter" select="$numFmt = 'lowerLetter'"/>
		<xsl:variable name="is_upper_roman" select="$numFmt = 'upperRoman'"/>
		<xsl:variable name="is_lower_roman" select="$numFmt = 'lowerRoman'"/>
		<xsl:variable name="is_decimal" select="$numFmt = 'decimal' or $numFmt = 'decimalZero'"/>
		
		<!-- DXF: num | bullet | alpha-upper | alpha-lower |  roman-upper | roman-lower | num-paren |
				  alpha-upper-paren | alpha-lower-paren |  roman-upper-paren | roman-lower-paren |
				  text-upper | text-mixed | text-lower | num-ordinal | num-double-paren |
				  alpha-upper-double-paren | alpha-lower-double-paren |  roman-upper-double-paren |
				  roman-lower-double-paren -->
		<xsl:choose>
			<xsl:when test="$double_paren">
				<xsl:choose>
					<xsl:when test="$is_upper_letter">alpha-upper-double-paren</xsl:when>
					<xsl:when test="$is_lower_letter">alpha-lower-double-paren</xsl:when>
					<xsl:when test="$is_upper_roman">roman-upper-double-paren</xsl:when>
					<xsl:when test="$is_lower_roman">roman-lower-double-paren</xsl:when>
					<xsl:when test="$is_decimal">num-double-paren</xsl:when>
					<xsl:otherwise>bullet</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:when test="$single_paren">
				<xsl:choose>
					<xsl:when test="$is_upper_letter">alpha-upper-paren</xsl:when>
					<xsl:when test="$is_lower_letter">alpha-lower-paren</xsl:when>
					<xsl:when test="$is_upper_roman">roman-upper-paren</xsl:when>
					<xsl:when test="$is_lower_roman">roman-lower-paren</xsl:when>
					<xsl:when test="$is_decimal">num-paren</xsl:when>
					<xsl:otherwise>bullet</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:choose>
					<xsl:when test="$is_upper_letter">alpha-upper</xsl:when>
					<xsl:when test="$is_lower_letter">alpha-lower</xsl:when>
					<xsl:when test="$is_upper_roman">roman-upper</xsl:when>
					<xsl:when test="$is_lower_roman">roman-lower</xsl:when>
					<xsl:when test="$is_decimal">num</xsl:when>
					<xsl:otherwise>bullet</xsl:otherwise>
				</xsl:choose>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<xsl:template name="strip-outer-parentheses">
		<xsl:param name="text"/>
		<xsl:variable name="first_char" select="substring($text, 1, 1)"/>
		<xsl:variable name="last_char" select="substring($text, string-length($text))"/>
		<xsl:choose>
			<xsl:when test="$first_char != ')' and $first_char != '(' and $last_char != ')' and $last_char != '('">
				<xsl:value-of select="$text"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:variable name="no_first_paren">
					<xsl:choose>
						<xsl:when test="$first_char = '(' or $first_char = ')'">
							<xsl:value-of select="substring($text, 2)"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="$text"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:call-template name="strip-outer-parentheses">
					<xsl:with-param name="text">
						<xsl:choose>
							<xsl:when test="$last_char = '(' or $last_char = ')'">
								<xsl:value-of select="substring($no_first_paren, 1, string-length($no_first_paren) - 1)"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$no_first_paren"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:with-param>
				</xsl:call-template>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	<!-- TODO: if we ever get a version of Xalan that supports XSLT 2.0, use the fn:tokenize() function to split the string and compare -->
	<xsl:template name="find.substring.attribute">
		<xsl:param name="string"/>
		<xsl:param name="delim"/>
		<xsl:param name="seperator"/>
		<xsl:param name="name"/>
		<xsl:variable name="item" select="substring-before($string, $delim)"/>
		<xsl:variable name="after" select="substring-after($string, $delim)"/>
		<xsl:choose>
			<xsl:when test="$item">
				<xsl:variable name="attr" select="substring-before($item, $seperator)"/>
				<xsl:variable name="value" select="substring-after($item, $seperator)"/>
				<xsl:choose>
					<xsl:when test="$attr = $name">
						<xsl:value-of select="$value"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:call-template name="find.substring.attribute">
							<xsl:with-param name="string" select="$after"/>
							<xsl:with-param name="delim" select="$delim"/>
							<xsl:with-param name="seperator" select="$seperator"/>
							<xsl:with-param name="name" select="$name"/>
						</xsl:call-template>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
</xsl:stylesheet>
